{
    "docs": [
        {
            "location": "/", 
            "text": "What's OpenVeo ?\n\n\nOpenVeo is a \nNode.js\n and \nAngularJS\n CMS. It embeds an HTTP server based on Express framework (\nExpress\n) and a plugin loader mechanism.\n\n\nThe core of the system (i.e. without any plugin) offers a simple connection form to the administration interface.\n\n\nThis interface gives access to a limited set of default features:\n\n\n\n\nUsers management\n\n\nPermissions and roles management\n\n\nWeb service management\n\n\nA profile page\n\n\n\n\nEach plugin brings zero to many additive administration pages and zero to many additive public pages.\n\n\nCompatibility\n\n\nOpenVeo has been tested on the following operating systems :\n\n\n\n\nWindows 7\n\n\nUbuntu 14.04\n\n\nDebian 8 (Jessy)\n\n\n\n\nOpenVeo has been tested on the following  :\n\n\n\n\nGoogle Chrome 45\n\n\nMozilla Firefox 40\n\n\nOpera 32\n\n\nInternet Explorer 11\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScreenshots\n\n\nLogin page\n\n\n\n\nBack end home page\n\n\n\n\nBack end roles management page\n\n\n\n\nBack end users management page\n\n\n\n\nBack end applications management page", 
            "title": "INTRODUCTION"
        }, 
        {
            "location": "/#whats-openveo", 
            "text": "OpenVeo is a  Node.js  and  AngularJS  CMS. It embeds an HTTP server based on Express framework ( Express ) and a plugin loader mechanism.  The core of the system (i.e. without any plugin) offers a simple connection form to the administration interface.  This interface gives access to a limited set of default features:   Users management  Permissions and roles management  Web service management  A profile page   Each plugin brings zero to many additive administration pages and zero to many additive public pages.", 
            "title": "What's OpenVeo ?"
        }, 
        {
            "location": "/#compatibility", 
            "text": "OpenVeo has been tested on the following operating systems :   Windows 7  Ubuntu 14.04  Debian 8 (Jessy)   OpenVeo has been tested on the following  :   Google Chrome 45  Mozilla Firefox 40  Opera 32  Internet Explorer 11", 
            "title": "Compatibility"
        }, 
        {
            "location": "/#screenshots", 
            "text": "Login page   Back end home page   Back end roles management page   Back end users management page   Back end applications management page", 
            "title": "Screenshots"
        }, 
        {
            "location": "/prerequisites/", 
            "text": "OpenVeo requires and has been tested on :\n\n\n\n\nNode.js\n (\n4.0.0 and \n5.0.0\n) - The server side of OpenVeo is written in Node.js\n\n\nNpm\n (\n=2.5.1 and \n3.0.0\n) - Npm will help you install all OpenVeo server dependencies\n\n\nMongoDB\n (\n=3.0.0\n) - OpenVeo stores all its datas inside a MongoDB database (users, roles, taxonomies etc.)\n\n\nBower\n (\n=1.5.2\n) - Bower will help you install all OpenVeo client dependencies, such as AngularJS and Bootstrap massively used in client side.\n\n\nImageMagick\n - Image Magick is used to dynamically generate derivated images (e.g. thumbs)\n\n\n\n\nNB :\n Moreover, for a Windows installation, Visual Studio Express is required as some OpenVeo dependencies are written in C and need to be compiled.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n\n\nnpm install @openveo/core\n\n\n\nNb :\n You will be prompted for some configuration. Don't worry if you made an error, you can edit configuration anytime using \nadvanced configuration\n.\n\n\nCreate a back end user\n\n\nOpenVeo CMS requires a super admin to access the back end. This user has full access to all the features of the back end and can't be removed. You can create it using the following command :\n\n\nnode install.js\n\n\n\nLaunch the application\n\n\nOpenVeo is now installed. Launch it :\n\n\nnode server.js\n\n\n\nLog to the back end\n\n\nYou can now access the back end at \nhttp://localhost:PORT/be/login\n (replace \nPORT\n by the port specified in \n~/.openveo/core/serverConf.json\n) using the super admin email and password.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "npm install @openveo/core  Nb :  You will be prompted for some configuration. Don't worry if you made an error, you can edit configuration anytime using  advanced configuration .", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#create-a-back-end-user", 
            "text": "OpenVeo CMS requires a super admin to access the back end. This user has full access to all the features of the back end and can't be removed. You can create it using the following command :  node install.js", 
            "title": "Create a back end user"
        }, 
        {
            "location": "/getting-started/#launch-the-application", 
            "text": "OpenVeo is now installed. Launch it :  node server.js", 
            "title": "Launch the application"
        }, 
        {
            "location": "/getting-started/#log-to-the-back-end", 
            "text": "You can now access the back end at  http://localhost:PORT/be/login  (replace  PORT  by the port specified in  ~/.openveo/core/serverConf.json ) using the super admin email and password.", 
            "title": "Log to the back end"
        }, 
        {
            "location": "/web-service/", 
            "text": "Introduction\n\n\nOpenVeo offers a Web Service which must be started as a different process and needs some extra configuration.\n\n\nConfigure the Web Service\n\n\nOpen \n~openveo/core/serverConf.json\n\n\n{\n  \nws\n : {\n    \nport\n : PORT // Replace PORT by the HTTP server port to use (e.g. 3001)\n  }\n}\n\n\n\n\nConfigure the Web Service logger\n\n\nOpen \n~openveo/core/loggerConf.json\n\n\n{\n  \nws\n : {\n    \nfileName\n : \n/var/log/openveo/openveo-ws.log\n, // Path to web service log file\n    \nlevel\n : \ninfo\n, // Log level\n    \nmaxFileSize\n : 1048576, // Maximum log file size (in Bytes)\n    \nmaxFiles\n : 2 // Maximum number of files archived\n  }\n}\n\n\n\n\nLaunch the Web Service\n\n\nIf you want to interact with OpenVeo through the Web Service, you need to start it.\nTo start the OpenVeo Web Service, just use the \n-ws\n option :\n\n\nnode server.js -ws\n\n\n\nAuhtenticate to the Web Service\n\n\nThe Web Service uses \nOAuth2\n for authentication.\n\n\nGet a client id and client secret\n\n\nYou can create a new application with a client id and a client secret through the back end (\nhttp://localhost:PORT/be/applications\n).\n\n\nGet an access token\n\n\nTo make Web Service requests you will need an Access token. To get an Access token, you must make an HTTP POST request on \n/token\n.\n\n\nExpected headers :\n\n\n\n\n'Authorization: Basic CREDENTIALS'\n (Replace CREDENTIALS by \"CLIENT_ID:CLIENT_SECRET\" encoded in base 64)\n\n\n\n\nExpected POST parameters :\n\n\n\n\n'grant_type' =\n 'client_credentials'\n\n\n\n\nYou will receive an Access token to authenticate each Web Service requests.\n\n\nPHP example\n\n\n$curlCookieJar = tempnam(sys_get_temp_dir(), \ncookies_\n);\n\n// Initialize a curl session\n$curlHandle = curl_init();\n\n// Default curl options for all future requests\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'GET');\ncurl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($curlHandle, CURLOPT_COOKIESESSION, false);\ncurl_setopt($curlHandle, CURLOPT_COOKIEJAR, $curlCookieJar);\ncurl_setopt($curlHandle, CURLOPT_COOKIEFILE, $curlCookieJar);\ncurl_setopt($curlHandle, CURLOPT_HEADER, false);\ncurl_setopt($curlHandle, CURLOPT_CONNECTTIMEOUT, 1);\ncurl_setopt($curlHandle, CURLOPT_TIMEOUT, 30);\n\n// Retrieve an oauth token\n// Use HTTP POST method\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'POST');\n\n// Replace {OPENVEO_URL} by the openveo server url\ncurl_setopt($curlHandle, CURLOPT_URL, '{OPENVEO_URL}/token');\n\n// Replace {CLIENT_ID} and {CLIENT_SECRET} by your credentials\ncurl_setopt($curlHandle, CURLOPT_HTTPHEADER, array(\n  'Authorization: Basic ' . base64_encode('{CLIENT_ID}:{CLIENT_SECRET}'),\n  'Content-Type: application/json'\n));\n\n// Set oauth grant type to client_credentials\ncurl_setopt($curlHandle, CURLOPT_POSTFIELDS, json_encode(array(\n    'grant_type' =\n 'client_credentials'\n  )\n));\n\n$resultWithToken = json_decode(curl_exec($curlHandle));\n\n\n\n\nAuthenticate a request\n\n\nAll requests to the Web Service must be authenticated using the HTTP header :\n\n\n\n\n'Authorization: Bearer TOKEN'\n (Replace TOKEN by your access token)\n\n\n\n\nPHP example\n\n\n// Get the list of videos\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'GET');\ncurl_setopt($curlHandle, CURLOPT_URL, '{OPENVEO_URL}/publish/videos');\ncurl_setopt($curlHandle, CURLOPT_HTTPHEADER, array(\n  'Authorization: Bearer ' . $resultWithToken-\naccess_token\n));\n\n// Got the list of videos\n$videos = json_decode(curl_exec($curlHandle));\n\n\n\n\nEndpoints\n\n\nNo endpoints are exposed by the core.\n\n\nClient libraries\n\n\nPHP client\n\n\nA \nPHP client\n is also available on Github to help interface with OpenVeo Web Service.", 
            "title": "Web Service"
        }, 
        {
            "location": "/web-service/#introduction", 
            "text": "OpenVeo offers a Web Service which must be started as a different process and needs some extra configuration.", 
            "title": "Introduction"
        }, 
        {
            "location": "/web-service/#configure-the-web-service", 
            "text": "Open  ~openveo/core/serverConf.json  {\n   ws  : {\n     port  : PORT // Replace PORT by the HTTP server port to use (e.g. 3001)\n  }\n}", 
            "title": "Configure the Web Service"
        }, 
        {
            "location": "/web-service/#configure-the-web-service-logger", 
            "text": "Open  ~openveo/core/loggerConf.json  {\n   ws  : {\n     fileName  :  /var/log/openveo/openveo-ws.log , // Path to web service log file\n     level  :  info , // Log level\n     maxFileSize  : 1048576, // Maximum log file size (in Bytes)\n     maxFiles  : 2 // Maximum number of files archived\n  }\n}", 
            "title": "Configure the Web Service logger"
        }, 
        {
            "location": "/web-service/#launch-the-web-service", 
            "text": "If you want to interact with OpenVeo through the Web Service, you need to start it.\nTo start the OpenVeo Web Service, just use the  -ws  option :  node server.js -ws", 
            "title": "Launch the Web Service"
        }, 
        {
            "location": "/web-service/#auhtenticate-to-the-web-service", 
            "text": "The Web Service uses  OAuth2  for authentication.", 
            "title": "Auhtenticate to the Web Service"
        }, 
        {
            "location": "/web-service/#get-a-client-id-and-client-secret", 
            "text": "You can create a new application with a client id and a client secret through the back end ( http://localhost:PORT/be/applications ).", 
            "title": "Get a client id and client secret"
        }, 
        {
            "location": "/web-service/#get-an-access-token", 
            "text": "To make Web Service requests you will need an Access token. To get an Access token, you must make an HTTP POST request on  /token .  Expected headers :   'Authorization: Basic CREDENTIALS'  (Replace CREDENTIALS by \"CLIENT_ID:CLIENT_SECRET\" encoded in base 64)   Expected POST parameters :   'grant_type' =  'client_credentials'   You will receive an Access token to authenticate each Web Service requests.  PHP example  $curlCookieJar = tempnam(sys_get_temp_dir(),  cookies_ );\n\n// Initialize a curl session\n$curlHandle = curl_init();\n\n// Default curl options for all future requests\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'GET');\ncurl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, true);\ncurl_setopt($curlHandle, CURLOPT_COOKIESESSION, false);\ncurl_setopt($curlHandle, CURLOPT_COOKIEJAR, $curlCookieJar);\ncurl_setopt($curlHandle, CURLOPT_COOKIEFILE, $curlCookieJar);\ncurl_setopt($curlHandle, CURLOPT_HEADER, false);\ncurl_setopt($curlHandle, CURLOPT_CONNECTTIMEOUT, 1);\ncurl_setopt($curlHandle, CURLOPT_TIMEOUT, 30);\n\n// Retrieve an oauth token\n// Use HTTP POST method\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'POST');\n\n// Replace {OPENVEO_URL} by the openveo server url\ncurl_setopt($curlHandle, CURLOPT_URL, '{OPENVEO_URL}/token');\n\n// Replace {CLIENT_ID} and {CLIENT_SECRET} by your credentials\ncurl_setopt($curlHandle, CURLOPT_HTTPHEADER, array(\n  'Authorization: Basic ' . base64_encode('{CLIENT_ID}:{CLIENT_SECRET}'),\n  'Content-Type: application/json'\n));\n\n// Set oauth grant type to client_credentials\ncurl_setopt($curlHandle, CURLOPT_POSTFIELDS, json_encode(array(\n    'grant_type' =  'client_credentials'\n  )\n));\n\n$resultWithToken = json_decode(curl_exec($curlHandle));", 
            "title": "Get an access token"
        }, 
        {
            "location": "/web-service/#authenticate-a-request", 
            "text": "All requests to the Web Service must be authenticated using the HTTP header :   'Authorization: Bearer TOKEN'  (Replace TOKEN by your access token)   PHP example  // Get the list of videos\ncurl_setopt($curlHandle, CURLOPT_CUSTOMREQUEST, 'GET');\ncurl_setopt($curlHandle, CURLOPT_URL, '{OPENVEO_URL}/publish/videos');\ncurl_setopt($curlHandle, CURLOPT_HTTPHEADER, array(\n  'Authorization: Bearer ' . $resultWithToken- access_token\n));\n\n// Got the list of videos\n$videos = json_decode(curl_exec($curlHandle));", 
            "title": "Authenticate a request"
        }, 
        {
            "location": "/web-service/#endpoints", 
            "text": "No endpoints are exposed by the core.", 
            "title": "Endpoints"
        }, 
        {
            "location": "/web-service/#client-libraries", 
            "text": "", 
            "title": "Client libraries"
        }, 
        {
            "location": "/web-service/#php-client", 
            "text": "A  PHP client  is also available on Github to help interface with OpenVeo Web Service.", 
            "title": "PHP client"
        }, 
        {
            "location": "/advanced-configuration/", 
            "text": "Introduction\n\n\nConfiguration files are all in user's directory under \n~/.openveo/core\n\n\n\n\n~/.openveo/core/conf.json\n\n\n~/.openveo/core/databaseConf.json\n\n\n~/.openveo/core/loggerConf.json\n\n\n~/.openveo/core/serverConf.json\n\n\n\n\nNb :\n You must restart OpenVeo servers after modifications.\n\n\nConfigure OpenVeo\n\n\nOpen \n~/.openveo/core/conf.json\n\n\n{\n  \npasswordHashKey\n : \nKEY\n // Replace KEY by a secret key used to encrypt users passwords\n}\n\n\n\n\nConfigure database access\n\n\nOpen \n~/.openveo/core/databaseConf.json\n\n\n{\n  \ntype\n : \nmongodb\n, // Do not change\n  \nhost\n : \nlocalhost\n, // MongoDB server host\n  \nport\n : 27017, // MongoDB port\n  \ndatabase\n : \nDATABASE_NAME\n, // Replace DATABASE_NAME by the name of the OpenVeo database\n  \nusername\n : \nDATABASE_USER_NAME\n, // Replace DATABASE_USER_NAME by the name of the database user\n  \npassword\n : \nDATABASE_USER_PWD\n // Replace DATABASE_USER_PWD  by the password of the database user\n}\n\n\n\n\nConfigure the logger\n\n\nOpen \n~/.openveo/core/loggerConf.json\n\n\n{\n  \napp\n : {\n    \nfileName\n : \n/var/log/openveo/openveo.log\n, // Path to application log file\n    \nlevel\n : \ninfo\n, // Log level\n    \nmaxFileSize\n : 1048576, // Maximum log file size (in Bytes)\n    \nmaxFiles\n : 2 // Maximum number of files archived\n  }\n}\n\n\n\n\nConfigure the server\n\n\nOpen \n~/.openveo/core/serverConf.json\n\n\n{\n  \napp\n : {\n    \nport\n : PORT, // Replace PORT by the HTTP server port to use (e.g. 3000)\n    \nsessionSecret\n : \nSECRET\n // Replace SECRET by a secret used to secure HTTP sessions\n  }\n}", 
            "title": "Advanced configuration"
        }, 
        {
            "location": "/advanced-configuration/#introduction", 
            "text": "Configuration files are all in user's directory under  ~/.openveo/core   ~/.openveo/core/conf.json  ~/.openveo/core/databaseConf.json  ~/.openveo/core/loggerConf.json  ~/.openveo/core/serverConf.json   Nb :  You must restart OpenVeo servers after modifications.", 
            "title": "Introduction"
        }, 
        {
            "location": "/advanced-configuration/#configure-openveo", 
            "text": "Open  ~/.openveo/core/conf.json  {\n   passwordHashKey  :  KEY  // Replace KEY by a secret key used to encrypt users passwords\n}", 
            "title": "Configure OpenVeo"
        }, 
        {
            "location": "/advanced-configuration/#configure-database-access", 
            "text": "Open  ~/.openveo/core/databaseConf.json  {\n   type  :  mongodb , // Do not change\n   host  :  localhost , // MongoDB server host\n   port  : 27017, // MongoDB port\n   database  :  DATABASE_NAME , // Replace DATABASE_NAME by the name of the OpenVeo database\n   username  :  DATABASE_USER_NAME , // Replace DATABASE_USER_NAME by the name of the database user\n   password  :  DATABASE_USER_PWD  // Replace DATABASE_USER_PWD  by the password of the database user\n}", 
            "title": "Configure database access"
        }, 
        {
            "location": "/advanced-configuration/#configure-the-logger", 
            "text": "Open  ~/.openveo/core/loggerConf.json  {\n   app  : {\n     fileName  :  /var/log/openveo/openveo.log , // Path to application log file\n     level  :  info , // Log level\n     maxFileSize  : 1048576, // Maximum log file size (in Bytes)\n     maxFiles  : 2 // Maximum number of files archived\n  }\n}", 
            "title": "Configure the logger"
        }, 
        {
            "location": "/advanced-configuration/#configure-the-server", 
            "text": "Open  ~/.openveo/core/serverConf.json  {\n   app  : {\n     port  : PORT, // Replace PORT by the HTTP server port to use (e.g. 3000)\n     sessionSecret  :  SECRET  // Replace SECRET by a secret used to secure HTTP sessions\n  }\n}", 
            "title": "Configure the server"
        }, 
        {
            "location": "/scalability/", 
            "text": "MongoDB database replication\n\n\nIf you want to take benefit of your \nMongoDB replication set\n, you can adapt your OpenVeo configuration.\n\n\nOpen \n~openveo/core/databaseConf.json\n and add a name for the ReplicaSet and a comma separated list of secondary servers.\n\n\n{\n  ...\n  \nreplicaSet\n : \nREPLICA_SET_NAME\n, // Replace REPLICA_SET_NAME by the name of the ReplicaSet\n  \nseedlist\n: \nIP_1:PORT_1,IP_2:PORT_2\n // The list comma separated list of secondary servers\n}\n\n\n\n\n{\n  \ntype\n : \nmongodb\n, // Do not change\n  \nhost\n : \nlocalhost\n, // MongoDB server host\n  \nport\n : 27017, // MongoDB port\n  \ndatabase\n : \nDATABASE_NAME\n, // Replace DATABASE_NAME by the name of the OpenVeo database\n  \nusername\n : \nDATABASE_USER_NAME\n, // Replace DATABASE_USER_NAME by the name of the database user\n  \npassword\n : \nDATABASE_USER_PWD\n, // Replace DATABASE_USER_PWD  by the password of the database user\n  \nreplicaSet\n : \nREPLICA_SET_NAME\n, // Replace REPLICA_SET_NAME by the name of the ReplicaSet\n  \nseedlist\n: \nIP_1:PORT_1,IP_2:PORT_2\n // The comma separated list of secondary servers\n}", 
            "title": "Scalability"
        }, 
        {
            "location": "/scalability/#mongodb-database-replication", 
            "text": "If you want to take benefit of your  MongoDB replication set , you can adapt your OpenVeo configuration.  Open  ~openveo/core/databaseConf.json  and add a name for the ReplicaSet and a comma separated list of secondary servers.  {\n  ...\n   replicaSet  :  REPLICA_SET_NAME , // Replace REPLICA_SET_NAME by the name of the ReplicaSet\n   seedlist :  IP_1:PORT_1,IP_2:PORT_2  // The list comma separated list of secondary servers\n}  {\n   type  :  mongodb , // Do not change\n   host  :  localhost , // MongoDB server host\n   port  : 27017, // MongoDB port\n   database  :  DATABASE_NAME , // Replace DATABASE_NAME by the name of the OpenVeo database\n   username  :  DATABASE_USER_NAME , // Replace DATABASE_USER_NAME by the name of the database user\n   password  :  DATABASE_USER_PWD , // Replace DATABASE_USER_PWD  by the password of the database user\n   replicaSet  :  REPLICA_SET_NAME , // Replace REPLICA_SET_NAME by the name of the ReplicaSet\n   seedlist :  IP_1:PORT_1,IP_2:PORT_2  // The comma separated list of secondary servers\n}", 
            "title": "MongoDB database replication"
        }, 
        {
            "location": "/production/", 
            "text": "Launch in production\n\n\nTo use OpenVeo in a production environment, start the server in production :\n\n\n# Starts OpenVeo application in production environment\nNODE_ENV=production node server.js\n\n# Starts OpenVeo Web Service in production environment\nNODE_ENV=production node server.js -ws\n\n\n\nNb :\n You should also consider launching the process as a deamon.\n\n\nReplicate database\n\n\nYou should consider replicating your database using \nMongoDB ReplicaSets\n. You can configure OpenVeo to \nuse your ReplicaSets\n.", 
            "title": "Production"
        }, 
        {
            "location": "/production/#launch-in-production", 
            "text": "To use OpenVeo in a production environment, start the server in production :  # Starts OpenVeo application in production environment\nNODE_ENV=production node server.js\n\n# Starts OpenVeo Web Service in production environment\nNODE_ENV=production node server.js -ws  Nb :  You should also consider launching the process as a deamon.", 
            "title": "Launch in production"
        }, 
        {
            "location": "/production/#replicate-database", 
            "text": "You should consider replicating your database using  MongoDB ReplicaSets . You can configure OpenVeo to  use your ReplicaSets .", 
            "title": "Replicate database"
        }, 
        {
            "location": "/developers/basics/", 
            "text": "HTTP server\n\n\nBased on \nExpress framwork\n, OpenVeo creates an HTTP server with a list of routes.\nRoutes are mounted on \n/\n while plugins routes are mounted on \n/PLUGIN_NAME\n with PLUGIN_NAME the name of the plugin.\nThere are two categories of routes :\n\n\n\n\nPublic routes : Routes accessible to anyone who has access to the url\n\n\nPrivate routes : Routes accessible only to users authenticated to the back end\n\n\n\n\nBack end\n\n\nOpenVeo core offers a back end as an AngularJS single page application accessible on \n/be\n. Without plugins, the back end has only limited features (users, roles, web service, profile page). And without plugins no front end is created. This is an important point. There is no generic front end, each plugin can define its own front pages on \n/PLUGIN_NAME\n base path.\n\n\nWeb Service\n\n\nOpenVeo core can create a \nWeb Service\n (using the option \n-ws\n when starting the server) mechanism based on oauth2 authentication. OpenVeo core, without plugins, does not expose any endpoints.\n\n\nThrough the back end you can create a new Web Service application with its associated list of scopes. Each new Web Service application will have an associated client id and client secret to authenticate to the Web Service. Thus you can create as many applications as you want with different scopes for each one.\n\n\nPlugins\n\n\nOpenVeo core loads all plugins found in \nnode_modules/@openveo/\n when starting the server. Each plugin can :\n\n\n\n\nCreate its own back end pages\n\n\nCreate public and private routes", 
            "title": "The basics"
        }, 
        {
            "location": "/developers/basics/#http-server", 
            "text": "Based on  Express framwork , OpenVeo creates an HTTP server with a list of routes.\nRoutes are mounted on  /  while plugins routes are mounted on  /PLUGIN_NAME  with PLUGIN_NAME the name of the plugin.\nThere are two categories of routes :   Public routes : Routes accessible to anyone who has access to the url  Private routes : Routes accessible only to users authenticated to the back end", 
            "title": "HTTP server"
        }, 
        {
            "location": "/developers/basics/#back-end", 
            "text": "OpenVeo core offers a back end as an AngularJS single page application accessible on  /be . Without plugins, the back end has only limited features (users, roles, web service, profile page). And without plugins no front end is created. This is an important point. There is no generic front end, each plugin can define its own front pages on  /PLUGIN_NAME  base path.", 
            "title": "Back end"
        }, 
        {
            "location": "/developers/basics/#web-service", 
            "text": "OpenVeo core can create a  Web Service  (using the option  -ws  when starting the server) mechanism based on oauth2 authentication. OpenVeo core, without plugins, does not expose any endpoints.  Through the back end you can create a new Web Service application with its associated list of scopes. Each new Web Service application will have an associated client id and client secret to authenticate to the Web Service. Thus you can create as many applications as you want with different scopes for each one.", 
            "title": "Web Service"
        }, 
        {
            "location": "/developers/basics/#plugins", 
            "text": "OpenVeo core loads all plugins found in  node_modules/@openveo/  when starting the server. Each plugin can :   Create its own back end pages  Create public and private routes", 
            "title": "Plugins"
        }, 
        {
            "location": "/developers/prerequisites/", 
            "text": "OpenVeo requires additional elements for development :\n\n\n\n\nGit\n - openveo-core is versioned with git\n\n\nRuby\n / \nSass\n / \nCompass\n - CSS is written using SASS / Compass\n\n\nKarma\n - Back end AngularJS single page application is unit tested using karma\n\n\nGrunt\n - Grunt is used to launch unit tests and compile sources\n\n\nProtractor\n - End to end tests are performed using Protractor", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/developers/installation/", 
            "text": "Clone project from git\n\n\ngit clone git@github.com:veo-labs/openveo-core.git openveo\n\n\n\nInstall project's dependencies\n\n\ncd openveo\nnpm install", 
            "title": "Installation"
        }, 
        {
            "location": "/developers/installation/#clone-project-from-git", 
            "text": "git clone git@github.com:veo-labs/openveo-core.git openveo", 
            "title": "Clone project from git"
        }, 
        {
            "location": "/developers/installation/#install-projects-dependencies", 
            "text": "cd openveo\nnpm install", 
            "title": "Install project's dependencies"
        }, 
        {
            "location": "/developers/conf/", 
            "text": "Introduction\n\n\nA consequent part of the development of openveo-core (and plugins) is made in \nconf.json\n file at project root. \nconf.json\n is used to :\n\n\n\n\nMap routes on actions\n\n\nCreate entities\n\n\nDefine back end permissions\n\n\nDefine back end menu items\n\n\nLoad back end scripts\n\n\nLoad back end CSS\n\n\nSet the list of directories containing templates\n\n\nDefine image styles\n\n\nDefine custom configuration\n\n\nDefine Web Service scopes\n\n\n\n\nMap routes on actions\n\n\nRoutes are separated into three categories : public, private and Web Service routes.\n\n\n{\n  \nroutes\n : {\n    \npublic\n : {\n      ...\n    },\n    \nprivate\n : {\n      ...\n    },\n    \nws\n : {\n      ...\n    }\n  }\n}\n\n\n\n\nRoute descriptor\n\n\nA route map an HTTP method and a path to an action (JavaScript function).\n\n\nThe route :\n\n\n\"get /logout\" : \"app/server/controllers/authenticationController.logoutAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nA GET request on /logout will call the function logoutAction exposed by module app/server/controllers/authenticationController.js\n\n\n\n\nThe route :\n\n\n\"post /authenticate\" : \"app/server/controllers/authenticationController.authenticateAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nA POST request on /authenticate will call the function authenticateAction exposed by module app/server/controllers/authenticationController.js\n\n\n\n\nThe route :\n\n\n\"/login\" : \"app/server/controllers/defaultController.defaultAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nAll requests on /login (GET, POST, DELETE, PUT) will call the function defaultAction exposed by module app/server/controllers/defaultController.js\n\n\n\n\nExample of valid routes :\n\n\n{\n  \nroutes\n : {\n    \npublic\n : {\n      \nget /test\n : \nadminExampleController.getTestAction\n,\n      \npost /test\n : \nadminExampleController.postTestAction\n,\n      \nput /test\n : \nadminExampleController.putTestAction\n,\n      \n/\n : \nexampleController.invalidAction\n,\n      \n/test\n : \ninvalid action\n\n    }\n  }\n}\n\n\n\n\nGroup routes\n\n\nYou can group actions by routes :\n\n\n{\n  \nroutes\n : {\n    \npublic\n : {\n      \n*\n : [\n        \nadminExampleController.allFirstAction\n,\n        \nadminExampleController.allSecondAction\n\n      ]\n    }\n  }\n}\n\n\n\n\nRoute parameters\n\n\nYou can add parameters using colon character :\n\n\n{\n  \nroutes\n : {\n    \npublic\n : {\n      \nDELETE /test/:id\n : \nadminExampleController.deleteTestAction\n\n    }\n  }\n}\n\n\n\n\nCreate entities\n\n\nEntities are elements subject to CRUD (\nC\nreate \nR\nead \nU\npdate \nD\nelete). OpenVeo core defines 4 entities :\n\n\n\n\napplication - Web Service client applications\n\n\ntaxonomy - Taxonomies (not directly used by the core)\n\n\nuser - Back end users\n\n\nrole - Back end roles\n\n\n\n\nEach entity will automatically have 3 associated back end permissions : create, update and delete.\n\n\nTo create a new entity you need to create a new EntityModel and a new EntityProvider. Let's say we want to create a new entity called \nbook\n.\n\n\nCreate entity provider\n\n\n'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookProvider.\n */\nfunction BookProvider(database) {\n\n  // In BookProvider collection \nbooks\n\n  openVeoAPI.EntityProvider.prototype.init.call(this, database, 'books');\n}\n\n// BookProvider must extend EntityProvider\nmodule.exports = BookProvider;\nutil.inherits(BookProvider, openVeoAPI.EntityProvider);\n\n\n\n\n\nCreate entity model\n\n\n'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\nvar BookProvider = process.require('BookProvider.js');\n\n/**\n * Creates a BookModel.\n */\nfunction BookModel() {\n  openVeoAPI.EntityModel.prototype.init.call(this, new BookProvider(openVeoAPI.applicationStorage.getDatabase()));\n}\n\nmodule.exports = BookModel;\nutil.inherits(BookModel, openVeoAPI.EntityModel);\n\n\n\n\nDeclare entity\n\n\nYou can now declare your entity in \nconf.json\n :\n\n\n{\n  \nentities\n : {\n    \nbook\n : \nBookModel\n\n  }\n}\n\n\n\n\nUse the entity\n\n\nNow that you entity \nbook\n is created you can see the 3 new permissions in the back end (create, update and delete). You can also perform CRUD operations on your entity using the following routes :\n\n\n\n\nget /crud/book/:id\n - Get a particular book\n\n\nget /crud/book\n - Get all books\n\n\npost /crud/book/:id\n - Update a particular book\n\n\nput /crud/book\n - Add a new book\n\n\ndelete /crud/book/:id\n - Delete a book\n\n\n\n\nDefine back end permissions\n\n\nEach role can have n associated permissions. Permissions are described in \nconf.json\n :\n\n\n{\n  \npermissions\n : [\n    ...\n  ]\n}\n\n\n\n\nCreate a permission\n\n\nLet's create new permissions \"sell\" and \"buy\" to sell / buy books.\n\n\n{\n  \npermissions\n : [\n    {\n      \nid\n : \nsell-book\n, // Permission id\n      \nname\n : \nSell\n, // Permission name\n      \ndescription\n : \nSell books\n, // Permission description\n      \npaths\n : [ // List of paths associated to the permission\n        \nget /sell*\n\n      ]\n    },\n    {\n      \nid\n : \nbuy-book\n, // Permission id\n      \nname\n : \nBuy\n, // Permission name\n      \ndescription\n : \nBuy books\n, // Permission description\n      \npaths\n : [ // List of paths associated to the permission\n        \nget /buy*\n\n      ]\n    }\n  ]\n}\n\n\n\n\nGroup permissions\n\n\nYou can group permissions to organize the list of permissions in the back end.\n\n\nNb\n : Actually OpenVeo only supports one sub level\n\n\n{\n  \npermissions\n : [\n    {\n      \nlabel\n: \nBooks\n, // Group label\n      \npermissions\n: [ // List of permission in the group\n        {\n          \nid\n : \nsell-book\n,\n          \nname\n : \nSell\n,\n          \ndescription\n : \nSell books\n,\n          \npaths\n : [\n            \nget /sell*\n\n          ]\n        },\n        {\n          \nid\n : \nbuy-book\n,\n          \nname\n : \nBuy\n,\n          \ndescription\n : \nBuy books\n,\n          \npaths\n : [\n            \nget /buy*\n\n          ]\n        }\n      ]\n    }\n  ]\n}\n\n\n\n\nUse permissions\n\n\nYou can assign your permission to a role through the back end or manipulate the permission using \nback end client\n (AngularJS application).\n\n\nDefine back end menu items\n\n\nBack end menu items are described in \nconf.json\n :\n\n\n{\n  \nbackOffice\n: {\n    \nmenu\n : [\n      ...\n    ]\n  }\n}\n\n\n\n\nAdd a menu item\n\n\nLet's create two new back end menu items.\n\n\n{\n  \nbackOffice\n: {\n    \nmenu\n : [\n      {\n        \nlabel\n : \nSell books\n, // Menu item name\n        \npath\n : \nsell-books\n, // Menu item path\n        \npermission\n : \nsell-book\n // Menu item associated permission\n      },\n      {\n        \nlabel\n : \nBuy books\n, // Menu item name\n        \npath\n : \nbuy-books\n, // Menu item path\n        \npermission\n : \nbuy-book\n // Menu item associated permission\n      }\n    ]\n  }\n}\n\n\n\n\nweight\n property helps order menu items, the larger the weight is, the better will be the item position.\n\n\npath\n defines the AngularJS root path (see \nback end client\n)\n\n\npermission\n associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed\n\n\nGroup menu items\n\n\nYou can group menu items as sub menu items.\n\n\nNb\n : Actually OpenVeo only supports one sub level of menu items\n\n\n{\n  \nbackOffice\n: {\n    \nmenu\n : [\n      {\n        \nweight\n : 100, // Position of the item in the menu\n        \nlabel\n : \nBooks\n, // Name of the menu item\n        \nsubMenu\n : [ // List of sub menu items\n          {\n            \nlabel\n : \nSell books\n, // Menu item name\n            \npath\n : \nsell-books\n, // Menu item path\n            \npermission\n : \nsell-book\n // Menu item associated permission\n          },\n          {\n            \nlabel\n : \nBuy books\n, // Menu item name\n            \npath\n : \nbuy-books\n, // Menu item path\n            \npermission\n : \nbuy-book\n // Menu item associated permission\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\n\nBack end scripts\n\n\nThe list of JavaScript files to load for the AngularJS back end application are defined in \nconf.json\n :\n\n\n{\n  \nbackOffice\n: {\n    \nscriptLibFiles\n : { // List of back end JavaScript files to load first\n      \nbase\n : [ // List of scripts to load on both development and production environments\n        ...\n      ],\n      \ndev\n : [ // List of scripts to load on development environment\n        ...\n      ],\n      \nprod\n : [ // List of script to load on production environment\n        ...\n      ]\n    },\n    \nscriptFiles\n : { // List of back end JavaScript files to load next\n      \ndev\n : [ // List of scripts to load on development environment\n        ...\n      ],\n      \nprod\n : [ // List of script to load on production environment\n        ...\n      ]\n    }\n  }\n}\n\n\n\n\nBack end CSS\n\n\nThe list of CSS files to load for the AngularJS back end application are defined in \nconf.json\n :\n\n\n{\n  \nbackOffice\n: {\n    \ncssFiles\n : [ // List of CSS to load\n      ...\n    ]\n  }\n}\n\n\n\n\nList of directories containing templates\n\n\nOpenVeo uses \nMustache\n as the template engine. Mustache requires directories were to look for potential templates. The list of directories is defined in \nconf.json\n :\n\n\n{\n  \nviewsFolders\n : [ // List of directories holding mustache templates\n    ...\n  ]\n}\n\n\n\n\nDefine image styles\n\n\nYou can define image styles in \nconf.json\n :\n\n\n{\n  \nimageProcessing\n: {\n    \nimagesFolders\n: [\nexample/images\n], // List of folders concerned by this style\n    \ncacheDir\n: \nexample/.thumbs\n, // Path of the directory containing generated images\n    \nquality\n: 50, // Compression level (from 0 to 100)\n    \nimagesStyle\n: { // Style to apply\n      \nsmall\n: 200 // Width (in px) of the image to generate for small style\n    }\n  }\n}\n\n\n\n\nDefault width is 10px if no image style is specified for the directory.\n\nDefault \ncacheDir\n is .thumbs directory at the root of the application.\n\nDefault quality is 90.\n\n\nThen you can call the image with your custom style \nsmall\n\n\nimg src=\nexample/images/image1.jpg?thumb=small\n/\n\n\n\n\n\nDefine custom configuration\n\n\nYou can define a custom configuration object in \nconf.json\n :\n\n\n{\n  \ncustom\n: {\n    \ncustomProperty1\n : \ncustomValue1\n,\n    \ncustomProperty2\n : 2\n  }\n}\n\n\n\n\nNb :\n Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it to configure your plugin.\n\n\nDefine Web Service scopes\n\n\nYou can define Web Service scopes in \nconf.json\n :\n\n\n{\n  \nwebServiceScopes\n : [\n    {\n      \nid\n: \nscopeId\n,\n      \nname\n : \nScope name\n,\n      \ndescription\n : \nScope description\n,\n      \npaths\n : [\n        \nget /book/sell/*\n,\n        \nget /book/books*\n\n      ]\n    }\n  ]\n}\n\n\n\n\nA scope is defined by an id, a name, a description and a list of authorized paths for a Web Service application who has access to this scope.\n\nRoutes like \n/book/sell/25\n or \n/book/books\n will be available for a Web Service application with the scope \nscopeId\n in the above example.", 
            "title": "conf.json"
        }, 
        {
            "location": "/developers/conf/#introduction", 
            "text": "A consequent part of the development of openveo-core (and plugins) is made in  conf.json  file at project root.  conf.json  is used to :   Map routes on actions  Create entities  Define back end permissions  Define back end menu items  Load back end scripts  Load back end CSS  Set the list of directories containing templates  Define image styles  Define custom configuration  Define Web Service scopes", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/conf/#map-routes-on-actions", 
            "text": "Routes are separated into three categories : public, private and Web Service routes.  {\n   routes  : {\n     public  : {\n      ...\n    },\n     private  : {\n      ...\n    },\n     ws  : {\n      ...\n    }\n  }\n}", 
            "title": "Map routes on actions"
        }, 
        {
            "location": "/developers/conf/#route-descriptor", 
            "text": "A route map an HTTP method and a path to an action (JavaScript function).  The route :  \"get /logout\" : \"app/server/controllers/authenticationController.logoutAction\"  Can be interpreted as :   A GET request on /logout will call the function logoutAction exposed by module app/server/controllers/authenticationController.js   The route :  \"post /authenticate\" : \"app/server/controllers/authenticationController.authenticateAction\"  Can be interpreted as :   A POST request on /authenticate will call the function authenticateAction exposed by module app/server/controllers/authenticationController.js   The route :  \"/login\" : \"app/server/controllers/defaultController.defaultAction\"  Can be interpreted as :   All requests on /login (GET, POST, DELETE, PUT) will call the function defaultAction exposed by module app/server/controllers/defaultController.js   Example of valid routes :  {\n   routes  : {\n     public  : {\n       get /test  :  adminExampleController.getTestAction ,\n       post /test  :  adminExampleController.postTestAction ,\n       put /test  :  adminExampleController.putTestAction ,\n       /  :  exampleController.invalidAction ,\n       /test  :  invalid action \n    }\n  }\n}", 
            "title": "Route descriptor"
        }, 
        {
            "location": "/developers/conf/#group-routes", 
            "text": "You can group actions by routes :  {\n   routes  : {\n     public  : {\n       *  : [\n         adminExampleController.allFirstAction ,\n         adminExampleController.allSecondAction \n      ]\n    }\n  }\n}", 
            "title": "Group routes"
        }, 
        {
            "location": "/developers/conf/#route-parameters", 
            "text": "You can add parameters using colon character :  {\n   routes  : {\n     public  : {\n       DELETE /test/:id  :  adminExampleController.deleteTestAction \n    }\n  }\n}", 
            "title": "Route parameters"
        }, 
        {
            "location": "/developers/conf/#create-entities", 
            "text": "Entities are elements subject to CRUD ( C reate  R ead  U pdate  D elete). OpenVeo core defines 4 entities :   application - Web Service client applications  taxonomy - Taxonomies (not directly used by the core)  user - Back end users  role - Back end roles   Each entity will automatically have 3 associated back end permissions : create, update and delete.  To create a new entity you need to create a new EntityModel and a new EntityProvider. Let's say we want to create a new entity called  book .", 
            "title": "Create entities"
        }, 
        {
            "location": "/developers/conf/#create-entity-provider", 
            "text": "'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookProvider.\n */\nfunction BookProvider(database) {\n\n  // In BookProvider collection  books \n  openVeoAPI.EntityProvider.prototype.init.call(this, database, 'books');\n}\n\n// BookProvider must extend EntityProvider\nmodule.exports = BookProvider;\nutil.inherits(BookProvider, openVeoAPI.EntityProvider);", 
            "title": "Create entity provider"
        }, 
        {
            "location": "/developers/conf/#create-entity-model", 
            "text": "'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\nvar BookProvider = process.require('BookProvider.js');\n\n/**\n * Creates a BookModel.\n */\nfunction BookModel() {\n  openVeoAPI.EntityModel.prototype.init.call(this, new BookProvider(openVeoAPI.applicationStorage.getDatabase()));\n}\n\nmodule.exports = BookModel;\nutil.inherits(BookModel, openVeoAPI.EntityModel);", 
            "title": "Create entity model"
        }, 
        {
            "location": "/developers/conf/#declare-entity", 
            "text": "You can now declare your entity in  conf.json  :  {\n   entities  : {\n     book  :  BookModel \n  }\n}", 
            "title": "Declare entity"
        }, 
        {
            "location": "/developers/conf/#use-the-entity", 
            "text": "Now that you entity  book  is created you can see the 3 new permissions in the back end (create, update and delete). You can also perform CRUD operations on your entity using the following routes :   get /crud/book/:id  - Get a particular book  get /crud/book  - Get all books  post /crud/book/:id  - Update a particular book  put /crud/book  - Add a new book  delete /crud/book/:id  - Delete a book", 
            "title": "Use the entity"
        }, 
        {
            "location": "/developers/conf/#define-back-end-permissions", 
            "text": "Each role can have n associated permissions. Permissions are described in  conf.json  :  {\n   permissions  : [\n    ...\n  ]\n}", 
            "title": "Define back end permissions"
        }, 
        {
            "location": "/developers/conf/#create-a-permission", 
            "text": "Let's create new permissions \"sell\" and \"buy\" to sell / buy books.  {\n   permissions  : [\n    {\n       id  :  sell-book , // Permission id\n       name  :  Sell , // Permission name\n       description  :  Sell books , // Permission description\n       paths  : [ // List of paths associated to the permission\n         get /sell* \n      ]\n    },\n    {\n       id  :  buy-book , // Permission id\n       name  :  Buy , // Permission name\n       description  :  Buy books , // Permission description\n       paths  : [ // List of paths associated to the permission\n         get /buy* \n      ]\n    }\n  ]\n}", 
            "title": "Create a permission"
        }, 
        {
            "location": "/developers/conf/#group-permissions", 
            "text": "You can group permissions to organize the list of permissions in the back end.  Nb  : Actually OpenVeo only supports one sub level  {\n   permissions  : [\n    {\n       label :  Books , // Group label\n       permissions : [ // List of permission in the group\n        {\n           id  :  sell-book ,\n           name  :  Sell ,\n           description  :  Sell books ,\n           paths  : [\n             get /sell* \n          ]\n        },\n        {\n           id  :  buy-book ,\n           name  :  Buy ,\n           description  :  Buy books ,\n           paths  : [\n             get /buy* \n          ]\n        }\n      ]\n    }\n  ]\n}", 
            "title": "Group permissions"
        }, 
        {
            "location": "/developers/conf/#use-permissions", 
            "text": "You can assign your permission to a role through the back end or manipulate the permission using  back end client  (AngularJS application).", 
            "title": "Use permissions"
        }, 
        {
            "location": "/developers/conf/#define-back-end-menu-items", 
            "text": "Back end menu items are described in  conf.json  :  {\n   backOffice : {\n     menu  : [\n      ...\n    ]\n  }\n}", 
            "title": "Define back end menu items"
        }, 
        {
            "location": "/developers/conf/#add-a-menu-item", 
            "text": "Let's create two new back end menu items.  {\n   backOffice : {\n     menu  : [\n      {\n         label  :  Sell books , // Menu item name\n         path  :  sell-books , // Menu item path\n         permission  :  sell-book  // Menu item associated permission\n      },\n      {\n         label  :  Buy books , // Menu item name\n         path  :  buy-books , // Menu item path\n         permission  :  buy-book  // Menu item associated permission\n      }\n    ]\n  }\n}  weight  property helps order menu items, the larger the weight is, the better will be the item position.  path  defines the AngularJS root path (see  back end client )  permission  associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed", 
            "title": "Add a menu item"
        }, 
        {
            "location": "/developers/conf/#group-menu-items", 
            "text": "You can group menu items as sub menu items.  Nb  : Actually OpenVeo only supports one sub level of menu items  {\n   backOffice : {\n     menu  : [\n      {\n         weight  : 100, // Position of the item in the menu\n         label  :  Books , // Name of the menu item\n         subMenu  : [ // List of sub menu items\n          {\n             label  :  Sell books , // Menu item name\n             path  :  sell-books , // Menu item path\n             permission  :  sell-book  // Menu item associated permission\n          },\n          {\n             label  :  Buy books , // Menu item name\n             path  :  buy-books , // Menu item path\n             permission  :  buy-book  // Menu item associated permission\n          }\n        ]\n      }\n    ]\n  }\n}", 
            "title": "Group menu items"
        }, 
        {
            "location": "/developers/conf/#back-end-scripts", 
            "text": "The list of JavaScript files to load for the AngularJS back end application are defined in  conf.json  :  {\n   backOffice : {\n     scriptLibFiles  : { // List of back end JavaScript files to load first\n       base  : [ // List of scripts to load on both development and production environments\n        ...\n      ],\n       dev  : [ // List of scripts to load on development environment\n        ...\n      ],\n       prod  : [ // List of script to load on production environment\n        ...\n      ]\n    },\n     scriptFiles  : { // List of back end JavaScript files to load next\n       dev  : [ // List of scripts to load on development environment\n        ...\n      ],\n       prod  : [ // List of script to load on production environment\n        ...\n      ]\n    }\n  }\n}", 
            "title": "Back end scripts"
        }, 
        {
            "location": "/developers/conf/#back-end-css", 
            "text": "The list of CSS files to load for the AngularJS back end application are defined in  conf.json  :  {\n   backOffice : {\n     cssFiles  : [ // List of CSS to load\n      ...\n    ]\n  }\n}", 
            "title": "Back end CSS"
        }, 
        {
            "location": "/developers/conf/#list-of-directories-containing-templates", 
            "text": "OpenVeo uses  Mustache  as the template engine. Mustache requires directories were to look for potential templates. The list of directories is defined in  conf.json  :  {\n   viewsFolders  : [ // List of directories holding mustache templates\n    ...\n  ]\n}", 
            "title": "List of directories containing templates"
        }, 
        {
            "location": "/developers/conf/#define-image-styles", 
            "text": "You can define image styles in  conf.json  :  {\n   imageProcessing : {\n     imagesFolders : [ example/images ], // List of folders concerned by this style\n     cacheDir :  example/.thumbs , // Path of the directory containing generated images\n     quality : 50, // Compression level (from 0 to 100)\n     imagesStyle : { // Style to apply\n       small : 200 // Width (in px) of the image to generate for small style\n    }\n  }\n}  Default width is 10px if no image style is specified for the directory. \nDefault  cacheDir  is .thumbs directory at the root of the application. \nDefault quality is 90.  Then you can call the image with your custom style  small  img src= example/images/image1.jpg?thumb=small /", 
            "title": "Define image styles"
        }, 
        {
            "location": "/developers/conf/#define-custom-configuration", 
            "text": "You can define a custom configuration object in  conf.json  :  {\n   custom : {\n     customProperty1  :  customValue1 ,\n     customProperty2  : 2\n  }\n}  Nb :  Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it to configure your plugin.", 
            "title": "Define custom configuration"
        }, 
        {
            "location": "/developers/conf/#define-web-service-scopes", 
            "text": "You can define Web Service scopes in  conf.json  :  {\n   webServiceScopes  : [\n    {\n       id :  scopeId ,\n       name  :  Scope name ,\n       description  :  Scope description ,\n       paths  : [\n         get /book/sell/* ,\n         get /book/books* \n      ]\n    }\n  ]\n}  A scope is defined by an id, a name, a description and a list of authorized paths for a Web Service application who has access to this scope. \nRoutes like  /book/sell/25  or  /book/books  will be available for a Web Service application with the scope  scopeId  in the above example.", 
            "title": "Define Web Service scopes"
        }, 
        {
            "location": "/developers/back-end/", 
            "text": "Introduction\n\n\nOpenVeo back end is an \nAngularJS\n single page application served on \n/be\n.\n\n\nThe back end relies on a couple of libraries :\n\n\n\n\nangular-route\n to perform single page application routing\n\n\nangular-animate\n for CSS animations\n\n\nangular-cookies\n for cookie management\n\n\nangular-i18n\n for AngularJS default translations\n\n\nangular-touch\n to manage gesture\n\n\nangular-bootstrap\n for basic user interface components\n\n\nangular-formly\n to build formulars from a JavaScript literal object\n\n\nangular-ui-tree\n to build an UI tree (not directly used by openveo-core)\n\n\nangular-xeditable\n to be able to edit entities in place\n\n\nng-jsonpath\n to search on a JSON object (not directly used by openveo-core)\n\n\nng-tasty\n to present entities in a dynamic paginated table\n\n\n\n\nStructure\n\n\nMain module (\nov\n)\n\n\nThe main AngularJS module of the back end is named \nov\n and is applied to the HTML root element.\n\n\nhtml ng-app=\nov\n ng-controller=\nMainController\n ng-strict-di\n\n\n  \nhead\n\n    \nbase href=\n/be/\n\n  \n/head\n\n\n  ...\n  \ndiv ng-view\n/div\n\n  ...\n\n/html\n\n\n\n\n\nIt has dependencies on all AngularJS libraries and all AngularJS modules described by OpenVeo plugins. It also defines all core routes :\n\n\n\n\n/be/login\n to access the login page\n\n\n/be\n to access the back end home page\n\n\n/be/applications\n to access Web service applications page\n\n\n/be/users\n to access users page\n\n\n/be/profile\n to access user's profile page\n\n\n/be/roles\n to access roles page\n\n\n\n\nNb:\n Available services / filters defined in \nov\n module are described in the \nAPI\n.\n\n\nAlert module (\nov.alert\n)\n\n\nOffers a service to control alerts for the whole application. Alerts are used to display a message to the user.\n\n\nNb:\n Available services defined in \nov.alert\n module are described in the \nAPI\n.\n\n\nAuthentication module (\nov.authentication\n)\n\n\nOffers a service to authenticate / logout or manipulate authenticated user informations. User information are stored locally using the ov.storage module.\n\n\nNb:\n Available services / filters defined in \nov.authentication\n module are described in the \nAPI\n.\n\n\nEntity module (\nov.entity\n)\n\n\nOffers a service to manage (CRUD) OpenVeo entities described in \nconf.json\n.\n\n\nNb:\n Available services defined in \nov.entity\n module are described in the \nAPI\n.\n\n\nI18n module (\nov.i18n\n)\n\n\nDefines a service to control back end internationalization and a \ntranslate\n filter to help translate ids from a dictionary.\n\n\nNb:\n Available services / filters defined in \nov.i18n\n module are described in the \nAPI\n.\n\n\nStorage module (\nov.storage\n)\n\n\nOffers a service to manipulate the local storage.\n\n\nNb:\n Available services defined in \nov.storage\n module are described in the \nAPI\n.\n\n\nTableForm module (\nov.tableForm\n)\n\n\nOffers a turnkey solution to build formulars and tasty tables.\n\n\nFormulars are the same as described in \nangular-formly\n.\n\n\nDatatables are a little different from the original \nng-tasty\n datable as actions can be assigned to a row and information about the row can be edited in place. Datatables needs an associated entity to work.\n\n\nAdd a new form\n\n\nFormulars are massively based on \nangular-formly\n.\nTo add a new formular, you have to place the generic formular partial in your HTML code and describe the expected form in your controller.\n\n\nInclude formular partial in your HTML.\n\n\nng-include src=\n'views/elements/form.html'\n/ng-include\n\n\n\n\n\nDescribes the formular in your controller.\n\n\n\n// List of books\n$scope.books = [{\n  \nisbn\n: \n50\n,\n  \nname\n: \nJourney to the Center of the Earth\n\n}];\n\n// Create a scope property \naddFormContainer\n\n$scope.addFormContainer = {};\n\n// Create a property \nmodel\n on \naddFormContainer\n, this is were formly will\n// stores form results\n// This is the model of the form\n$scope.addFormContainer.model = {};\n\n// Describe fields just like in formly documentation\n$scope.addFormContainer.fields = [\n  {\n    key: 'name',\n    type: 'horizontalInput',\n    templateOptions: {\n      label: 'Label of the name field',\n      required: true,\n      description: 'Description of the name field'\n    }\n  },\n  {\n    key: 'books',\n    type: 'horizontalCheckList',\n    templateOptions: {\n      label: 'Books',\n      required: false,\n      options: $scope.books,\n      valueProp: 'isbn',\n      labelProp: 'name',\n      description: 'List of books'\n    },\n    expressionProperties: {\n      'templateOptions.disabled': '!model.name' // disabled when book name is blank\n    }\n  }\n];\n\n// Add formular submit function\n$scope.addFormContainer.onSubmit = function(model) {\n\n  // Return Angularjs promises with its own success or error callback\n  // Code to save the formular\n  // Generic error or success callback are already chained and executed by the form container\n  // in order to display the right message to user and update the form\n  return promise;\n};\n\n\n\n\nAdd a new datatable\n\n\nTables are massively based on \nng-tasty\n.\nTo add a new datatable, you have to place the generic datatable partial in your HTML code and describe the datatable expected behavior in your controller.\n\n\nInclude datatable partial in your HTML.\n\n\nng-include src=\n'views/elements/dataTable.html'\n/ng-include\n\n\n\n\n\nDescribes the datatable in your controller.\n\n\nFor the example, assume that you need to display a collection of \nbook\n entity.\n\n\n{\n  \nisbn\n: \n50\n,\n  \nname\n: \nJourney to the Center of the Earth\n,\n  \ndescription\n : \nThe story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock\n\n}\n\n\n\n\n\n\nInitialize tableContainer Object:\n\n\n\n\n// Create tableContainer Object used by DataTable controller\n$scope.tableContainer = {};\n\n// Initialize the entity type to enable DataTable controller to retrieve the right entity\n$scope.tableContainer.entityType = 'book';\n\n\n\n\n\n\nInitialize search filters\n\n\n\n\n$scope.tableContainer.filterBy = [\n  {\n    key: 'name',  // properties to filter on\n    value: '',    // initial value\n    label: 'Label of the name search filter'\n  }\n];\n\n\n\n\nFilters default type is text. Filter type can be set by adding \ntype\n properties to filter object.\n\n\n{\n  key: 'author',\n  type: 'select',\n  options : selectOptions,\n  value: '',\n  label: 'Label of the author search filter',\n  filterWithChildren: true  // default:false; if true table filter will select with the selectId AND additionnal id set in the \nchildren\n key of the selected options\n},\n{\n  key: 'date',\n  type: 'date',\n  value: '',\n  label : 'Label of the date search filter'\n}\n\n\n\n\nWhere \nselectOptions\n need to be describe in this format:\n\n\n[\n  {\n    \nvalue\n: 'id',\n    \nname\n: 'title',\n    \nchildren\n : 'id1,id2,id3'\n  },\n  ...\n]\n\n\n\n\n\n\nInitialize DataTable headers\n\n\n\n\n// Each column need to display a property,\n// Automatically, a sort filter is enable on each column except 'Action' column\n$scope.tableContainer.header = [{\n  key: 'name',                      // property co display and sort in column    \n  name: 'Label of the name column',\n  class: ['col-xs-12 col-sm-11']    // css class to add on header cell\n},\n{\n  key: 'action',                    \n  name: 'Label for action button' ,\n  class: [' hidden-xs col-sm-1'],\n}];\n\n\n\n\nHeader object 'action' is \nREQUIRED\n and not bind any sort filter.\n\n\nHeaders default type is text. Filter type can be set by adding \ntype\n properties to filter object.\nDefault \ndate\n (timestamp) and \ntext\n value are enabled. \nBut you can add any type if you make your own custom cell rendrer (see after)\n\n\n{\n  key: 'date', \n  name: 'Label of the date column',\n  type: 'date'\n},\n{\n  key: 'author', \n  name: 'Label of the author column',\n  type: 'author'\n}\n\n\n\n\n\n\nAdd a custom cell template renderer according to column key and row value\n\n\n\n\n//Usefull to add HTML value, or filtered value\n//if not defined, can print date and text\n//if defined, add custom cells renderer to date and text \n$scope.tableContainer.cellTheme = '/path/to/cells/template.html';\n\n\n\n\nFor example (assuming that \nentities\n is the header type to render, an \nrow[entities.key]\n, the value to display)\n\n\nspan ng-if=\nentities.type \n entities.type == 'type1' \n row[entities.key]\n{{row[entities.key] | filterType1}}\n/span\n\n\nspan ng-if=\nentities.type \n entities.type == 'type2'\n ng-bind-html=\nrow[entities.key] | filterType2\n/span\n\n\n\n\n\n \nBE CAREFUL ABOUT PERFORMANCES WHEN USING YOUR OWN FILTERS\n \n\n\n\n\nInitialize action enable on each row\n\n\n\n\n$scope.tableContainer.actions = [{\n  label: 'Label of action',\n\n  // Enable a Popup confirmation before action execution, default: false if not defined\n  warningPopup: true,\n\n  // Condition to enable the action in the dropdown button action\n  condition: function(row) {      \n    return $scope.rights.delete \n !row.locked \n !row.saving;\n  },\n\n  // Function to execute when the action is executed by button\n  callback: function(row, reload) {\n    // row is the book object on which the action is executed\n    action(row.id);\n    // call reload if dataTable need to be reloaded\n    reload();\n  },\n\n  // Function to execute when the action is executed by select checkbox action\n  // If not defined, this action can't be seen in checkbox actions\n  global: function(selected, reload) {\n    // selected is the list of selected entity id when global action is executed\n    // exemple: [12345,12346,12347,12348,12349]\n    actions(selected, reload);\n  }\n}];\n\n\n\n\n\n\nInitialize initial sort\n\n\n\n\n$scope.tableContainer.init = {\n  sortBy: 'name',  // initial sort key, default: first header column key if not defined\n  sortOrder: 'dsc' // initial sort order, default: 'asc' if not defined\n};\n\n\n\n\n\n\nDisplay checkbox global selection\n\n\n\n\n//default true if not defined;\n$scope.tableContainer.showSelectAll = true;\n\n\n\n\nYou can reload a display table manually from other controller by injecting the \nTableReloadEventService\n and calling\n\n\ntableReloadEventService.broadcast();\n\n\n\n\nDatatable dependency: edit a row\n\n\nDataTable is dependent of an edit form. This form specify what information user can access and/or modify.\nAll properties described in the \nAdd a new form\n section can be used to describe the form.\nMain differencies are that the form need to be initialized by the open row (the model is not exposed), and that form fields MUST be extend with an \nangular-xeditable\n field\n\n\n\n\nInitialize editFormContainer object\n\n\n\n\n// Create a scope property \neditFormContainer\n\n$scope.addFormContainer = {};\n\n// Create a property \nmodel\n on \neditFormContainer\n, this is were formly will\n// stores form results\n// This is the model of the form\n$scope.editFormContainer.model = {};\n\n// Initialize the entity type to retrieve before the row is updated \n// to always update the latest value in database.\n$scope.editFormContainer.entityType = 'book';\n\n// Add formular submit function\n$scope.editFormContainer.onSubmit = function(model) {\n    return promises;\n};\n\n// Define if a row can be toggled or not\n$scope.editFormContainer.conditionToggleDetail = function(row) {\n  return row.state !== 0;\n};\n// Define if a row can be edit or not\n$scope.editFormContainer.conditionEditDetail = function(row) {\n  return !row.locked;\n};\n\n\n\n\n\n\nSet Fields \n\n\n\n\n// Describe fields just like in formly documentation, extends with openveo xeditable type\n// editableInput, editableChecklist, editableChecklist\n$scope.editFormContainer.fields = {\n  // the key to be used in the model values\n  key: 'name',\n  type: 'horizontalExtendInput', //editableInput wrapped with horizontal layout\n  templateOptions: {\n    label: 'label for name input',\n    required: true\n  }\n};\n\n\n\n\n\n\nSet Fields dynamically\n\n\n\n\n// Function call when the form is displayed\n// Usefull to add fields dynamically according to the open row, \n// or retrieve information relative to the row\n$scope.editFormContainer.init = function(row) {\n  if(row.state == SHOW.PROPERTY){\n    var newField = {\n      key: 'property',\n      type: 'horizontalExtendInput',\n      model: row.property,\n      templateOptions: {\n        label: 'Label of the new property field'\n      }\n    };\n    $scope.editFormContainer.fields.push(newField);\n  }\n}\n\n\n\n\nFields type\n\n\nIn order to enhance forms, you can add your own fields type by specified them in the \nformlyConfig\n Object in \napp.run\n:\n\n\n// This type allready in Openveo can right an text in a well componant\nformlyConfig.setType({\n  name: 'emptyrow',\n  template: '\ndiv class=\nwell well-sm\n{{to.message}}\n/div\n',\n  wrapper: ['horizontalBootstrapLabel', 'bootstrapHasError']\n});\n\n// to use it :\n\n$scope.editFormContainer.fields = [\n{\n  noFormControl: true,\n  type: 'emptyrow',\n  templateOptions: {\n    label: 'label of the not editable row',\n    message: 'not editable value to display'\n  }\n}]\n\n\n\n\nXeditable fields that already exist are : editableInput, editableChecklist, editableChecklist, emptyrow\n\n\nOther xeditable extend fields can be added but, to be used in an edit form, need to be wrapped in the \nformlyConfig\n Object:\n\n\n    formlyConfig.setType({\n      name: 'horizontalExtendFieldType',\n      extends: 'editableFieldType',\n      wrapper: ['horizontalBootstrapLabel', 'bootstrapHasError']\n    });", 
            "title": "Back end AngularJS"
        }, 
        {
            "location": "/developers/back-end/#introduction", 
            "text": "OpenVeo back end is an  AngularJS  single page application served on  /be .  The back end relies on a couple of libraries :   angular-route  to perform single page application routing  angular-animate  for CSS animations  angular-cookies  for cookie management  angular-i18n  for AngularJS default translations  angular-touch  to manage gesture  angular-bootstrap  for basic user interface components  angular-formly  to build formulars from a JavaScript literal object  angular-ui-tree  to build an UI tree (not directly used by openveo-core)  angular-xeditable  to be able to edit entities in place  ng-jsonpath  to search on a JSON object (not directly used by openveo-core)  ng-tasty  to present entities in a dynamic paginated table", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/back-end/#structure", 
            "text": "", 
            "title": "Structure"
        }, 
        {
            "location": "/developers/back-end/#main-module-ov", 
            "text": "The main AngularJS module of the back end is named  ov  and is applied to the HTML root element.  html ng-app= ov  ng-controller= MainController  ng-strict-di \n\n   head \n     base href= /be/ \n   /head \n\n  ...\n   div ng-view /div \n  ... /html   It has dependencies on all AngularJS libraries and all AngularJS modules described by OpenVeo plugins. It also defines all core routes :   /be/login  to access the login page  /be  to access the back end home page  /be/applications  to access Web service applications page  /be/users  to access users page  /be/profile  to access user's profile page  /be/roles  to access roles page   Nb:  Available services / filters defined in  ov  module are described in the  API .", 
            "title": "Main module (ov)"
        }, 
        {
            "location": "/developers/back-end/#alert-module-ovalert", 
            "text": "Offers a service to control alerts for the whole application. Alerts are used to display a message to the user.  Nb:  Available services defined in  ov.alert  module are described in the  API .", 
            "title": "Alert module (ov.alert)"
        }, 
        {
            "location": "/developers/back-end/#authentication-module-ovauthentication", 
            "text": "Offers a service to authenticate / logout or manipulate authenticated user informations. User information are stored locally using the ov.storage module.  Nb:  Available services / filters defined in  ov.authentication  module are described in the  API .", 
            "title": "Authentication module (ov.authentication)"
        }, 
        {
            "location": "/developers/back-end/#entity-module-oventity", 
            "text": "Offers a service to manage (CRUD) OpenVeo entities described in  conf.json .  Nb:  Available services defined in  ov.entity  module are described in the  API .", 
            "title": "Entity module (ov.entity)"
        }, 
        {
            "location": "/developers/back-end/#i18n-module-ovi18n", 
            "text": "Defines a service to control back end internationalization and a  translate  filter to help translate ids from a dictionary.  Nb:  Available services / filters defined in  ov.i18n  module are described in the  API .", 
            "title": "I18n module (ov.i18n)"
        }, 
        {
            "location": "/developers/back-end/#storage-module-ovstorage", 
            "text": "Offers a service to manipulate the local storage.  Nb:  Available services defined in  ov.storage  module are described in the  API .", 
            "title": "Storage module (ov.storage)"
        }, 
        {
            "location": "/developers/back-end/#tableform-module-ovtableform", 
            "text": "Offers a turnkey solution to build formulars and tasty tables.  Formulars are the same as described in  angular-formly .  Datatables are a little different from the original  ng-tasty  datable as actions can be assigned to a row and information about the row can be edited in place. Datatables needs an associated entity to work.  Add a new form  Formulars are massively based on  angular-formly .\nTo add a new formular, you have to place the generic formular partial in your HTML code and describe the expected form in your controller.  Include formular partial in your HTML.  ng-include src= 'views/elements/form.html' /ng-include   Describes the formular in your controller.  \n// List of books\n$scope.books = [{\n   isbn :  50 ,\n   name :  Journey to the Center of the Earth \n}];\n\n// Create a scope property  addFormContainer \n$scope.addFormContainer = {};\n\n// Create a property  model  on  addFormContainer , this is were formly will\n// stores form results\n// This is the model of the form\n$scope.addFormContainer.model = {};\n\n// Describe fields just like in formly documentation\n$scope.addFormContainer.fields = [\n  {\n    key: 'name',\n    type: 'horizontalInput',\n    templateOptions: {\n      label: 'Label of the name field',\n      required: true,\n      description: 'Description of the name field'\n    }\n  },\n  {\n    key: 'books',\n    type: 'horizontalCheckList',\n    templateOptions: {\n      label: 'Books',\n      required: false,\n      options: $scope.books,\n      valueProp: 'isbn',\n      labelProp: 'name',\n      description: 'List of books'\n    },\n    expressionProperties: {\n      'templateOptions.disabled': '!model.name' // disabled when book name is blank\n    }\n  }\n];\n\n// Add formular submit function\n$scope.addFormContainer.onSubmit = function(model) {\n\n  // Return Angularjs promises with its own success or error callback\n  // Code to save the formular\n  // Generic error or success callback are already chained and executed by the form container\n  // in order to display the right message to user and update the form\n  return promise;\n};  Add a new datatable  Tables are massively based on  ng-tasty .\nTo add a new datatable, you have to place the generic datatable partial in your HTML code and describe the datatable expected behavior in your controller.  Include datatable partial in your HTML.  ng-include src= 'views/elements/dataTable.html' /ng-include   Describes the datatable in your controller.  For the example, assume that you need to display a collection of  book  entity.  {\n   isbn :  50 ,\n   name :  Journey to the Center of the Earth ,\n   description  :  The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock \n}   Initialize tableContainer Object:   // Create tableContainer Object used by DataTable controller\n$scope.tableContainer = {};\n\n// Initialize the entity type to enable DataTable controller to retrieve the right entity\n$scope.tableContainer.entityType = 'book';   Initialize search filters   $scope.tableContainer.filterBy = [\n  {\n    key: 'name',  // properties to filter on\n    value: '',    // initial value\n    label: 'Label of the name search filter'\n  }\n];  Filters default type is text. Filter type can be set by adding  type  properties to filter object.  {\n  key: 'author',\n  type: 'select',\n  options : selectOptions,\n  value: '',\n  label: 'Label of the author search filter',\n  filterWithChildren: true  // default:false; if true table filter will select with the selectId AND additionnal id set in the  children  key of the selected options\n},\n{\n  key: 'date',\n  type: 'date',\n  value: '',\n  label : 'Label of the date search filter'\n}  Where  selectOptions  need to be describe in this format:  [\n  {\n     value : 'id',\n     name : 'title',\n     children  : 'id1,id2,id3'\n  },\n  ...\n]   Initialize DataTable headers   // Each column need to display a property,\n// Automatically, a sort filter is enable on each column except 'Action' column\n$scope.tableContainer.header = [{\n  key: 'name',                      // property co display and sort in column    \n  name: 'Label of the name column',\n  class: ['col-xs-12 col-sm-11']    // css class to add on header cell\n},\n{\n  key: 'action',                    \n  name: 'Label for action button' ,\n  class: [' hidden-xs col-sm-1'],\n}];  Header object 'action' is  REQUIRED  and not bind any sort filter.  Headers default type is text. Filter type can be set by adding  type  properties to filter object.\nDefault  date  (timestamp) and  text  value are enabled. \nBut you can add any type if you make your own custom cell rendrer (see after)  {\n  key: 'date', \n  name: 'Label of the date column',\n  type: 'date'\n},\n{\n  key: 'author', \n  name: 'Label of the author column',\n  type: 'author'\n}   Add a custom cell template renderer according to column key and row value   //Usefull to add HTML value, or filtered value\n//if not defined, can print date and text\n//if defined, add custom cells renderer to date and text \n$scope.tableContainer.cellTheme = '/path/to/cells/template.html';  For example (assuming that  entities  is the header type to render, an  row[entities.key] , the value to display)  span ng-if= entities.type   entities.type == 'type1'   row[entities.key] {{row[entities.key] | filterType1}} /span  span ng-if= entities.type   entities.type == 'type2'  ng-bind-html= row[entities.key] | filterType2 /span     BE CAREFUL ABOUT PERFORMANCES WHEN USING YOUR OWN FILTERS     Initialize action enable on each row   $scope.tableContainer.actions = [{\n  label: 'Label of action',\n\n  // Enable a Popup confirmation before action execution, default: false if not defined\n  warningPopup: true,\n\n  // Condition to enable the action in the dropdown button action\n  condition: function(row) {      \n    return $scope.rights.delete   !row.locked   !row.saving;\n  },\n\n  // Function to execute when the action is executed by button\n  callback: function(row, reload) {\n    // row is the book object on which the action is executed\n    action(row.id);\n    // call reload if dataTable need to be reloaded\n    reload();\n  },\n\n  // Function to execute when the action is executed by select checkbox action\n  // If not defined, this action can't be seen in checkbox actions\n  global: function(selected, reload) {\n    // selected is the list of selected entity id when global action is executed\n    // exemple: [12345,12346,12347,12348,12349]\n    actions(selected, reload);\n  }\n}];   Initialize initial sort   $scope.tableContainer.init = {\n  sortBy: 'name',  // initial sort key, default: first header column key if not defined\n  sortOrder: 'dsc' // initial sort order, default: 'asc' if not defined\n};   Display checkbox global selection   //default true if not defined;\n$scope.tableContainer.showSelectAll = true;  You can reload a display table manually from other controller by injecting the  TableReloadEventService  and calling  tableReloadEventService.broadcast();  Datatable dependency: edit a row  DataTable is dependent of an edit form. This form specify what information user can access and/or modify.\nAll properties described in the  Add a new form  section can be used to describe the form.\nMain differencies are that the form need to be initialized by the open row (the model is not exposed), and that form fields MUST be extend with an  angular-xeditable  field   Initialize editFormContainer object   // Create a scope property  editFormContainer \n$scope.addFormContainer = {};\n\n// Create a property  model  on  editFormContainer , this is were formly will\n// stores form results\n// This is the model of the form\n$scope.editFormContainer.model = {};\n\n// Initialize the entity type to retrieve before the row is updated \n// to always update the latest value in database.\n$scope.editFormContainer.entityType = 'book';\n\n// Add formular submit function\n$scope.editFormContainer.onSubmit = function(model) {\n    return promises;\n};\n\n// Define if a row can be toggled or not\n$scope.editFormContainer.conditionToggleDetail = function(row) {\n  return row.state !== 0;\n};\n// Define if a row can be edit or not\n$scope.editFormContainer.conditionEditDetail = function(row) {\n  return !row.locked;\n};   Set Fields    // Describe fields just like in formly documentation, extends with openveo xeditable type\n// editableInput, editableChecklist, editableChecklist\n$scope.editFormContainer.fields = {\n  // the key to be used in the model values\n  key: 'name',\n  type: 'horizontalExtendInput', //editableInput wrapped with horizontal layout\n  templateOptions: {\n    label: 'label for name input',\n    required: true\n  }\n};   Set Fields dynamically   // Function call when the form is displayed\n// Usefull to add fields dynamically according to the open row, \n// or retrieve information relative to the row\n$scope.editFormContainer.init = function(row) {\n  if(row.state == SHOW.PROPERTY){\n    var newField = {\n      key: 'property',\n      type: 'horizontalExtendInput',\n      model: row.property,\n      templateOptions: {\n        label: 'Label of the new property field'\n      }\n    };\n    $scope.editFormContainer.fields.push(newField);\n  }\n}  Fields type  In order to enhance forms, you can add your own fields type by specified them in the  formlyConfig  Object in  app.run :  // This type allready in Openveo can right an text in a well componant\nformlyConfig.setType({\n  name: 'emptyrow',\n  template: ' div class= well well-sm {{to.message}} /div ',\n  wrapper: ['horizontalBootstrapLabel', 'bootstrapHasError']\n});\n\n// to use it :\n\n$scope.editFormContainer.fields = [\n{\n  noFormControl: true,\n  type: 'emptyrow',\n  templateOptions: {\n    label: 'label of the not editable row',\n    message: 'not editable value to display'\n  }\n}]  Xeditable fields that already exist are : editableInput, editableChecklist, editableChecklist, emptyrow  Other xeditable extend fields can be added but, to be used in an edit form, need to be wrapped in the  formlyConfig  Object:      formlyConfig.setType({\n      name: 'horizontalExtendFieldType',\n      extends: 'editableFieldType',\n      wrapper: ['horizontalBootstrapLabel', 'bootstrapHasError']\n    });", 
            "title": "TableForm module (ov.tableForm)"
        }, 
        {
            "location": "/developers/write-plugin/", 
            "text": "Introduction\n\n\nAs OpenVeo server starts, all plugins found in \nnode_modules/@openveo/\n will be loaded. Each plugin can add routes and add its own pages in the back end.\n\n\nLet's pretend we want to create a plugin called \nbook\n to manage a list of books.\n\n\nCreate plugin's directory\n\n\nThe first thing we need is a plugin's directory, create a directory \nbook\n under \nnode_modules/@openveo/\n (\nnode_modules/@openveo/book\n).\n\n\nCreate plugin's main file\n\n\nA plugin must have a class which extends \nPlugin\n class.\n\n\nCreate a file \nBookPlugin.js\n at the root of your plugin directory.\n\n\n'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar express = require('express');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookPlugin.\n */\nfunction BookPlugin() {\n\n  // Creates a public router\n  // It will be automatically mounted on /book/ by the core\n  this.router = express.Router();\n\n  // Creates a private router\n  // All routes associated to the private router require a back end authentication\n  // It will be automatically mounted on /be/book/ by the core\n  this.privateRouter = express.Router();\n\n  // Creates a Web Service router\n  // All routes associated to the Web Service router will be part of the Web Service\n  // It will be automatically mounter on /book/ by the core (but on another server)\n  this.webServiceRouter = express.Router();\n\n}\n\n// Expose BookPlugin\nmodule.exports = BookPlugin;\n\n// Extends Plugin\nutil.inherits(BookPlugin, openVeoAPI.Plugin);\n\n/**\n * Optional \nstart\n method automatically called by core application\n * after plugin is loaded.\n */\nBookPlugin.prototype.start = function() {\n  console.log('Book plugin loaded');\n};\n\n\n\n\nIf you don't want to expose public routes, private routes or Web Service routes, just remove the corresponding router.\n\n\nCreate plugin's entry point\n\n\nA plugin must have an entry point. Either the one described in your \npackage.json\n file (if you have one) or an \nindex.js\n file. This is the file loaded by the core.\n\n\nCreate a file \nindex.js\n at the root of your plugin directory.\n\n\n'use strict';\n\n// Module dependencies\nvar path = require('path');\n\n// Set module root directory\nprocess.rootBook = __dirname;\n\n// Define a new method on process object to be able to require\n// a module with a path relative to plugin's root directory\nprocess.requireBook = function(filePath) {\n  return require(path.join(process.requireBook, filePath));\n};\n\n// Expose the BookPlugin\nmodule.exports = process.requireBook('app/server/BookPlugin.js');\n\n\n\n\nAs the plugin will be loaded by OpenVeo core, root of the OpenVeo application will be the root of OpenVeo core and not the root of your plugin. To avoid confusion and collision between the core and your plugin, define a property process.root\nPLUGIN_NAME\n to have a reference to the root of your plugin.\n\n\nA best practice is to also add a require\nPLUGIN_NAME\n function to load your JavaScript files with paths relative to the root of your plugin.\n\nFor example, if you want to load a file \ndir/test.js\n from file \ndir/subDir/index.js\n instead of writing :\n\n\nvar test = require('../test.js');\n\n\n\n\nYou can write :\n\n\nvar test = process.requireBook('dir/subDir/test.js');\n\n\n\n\nLike that moving the file \nindex.js\n won't break your code.\n\n\nAt this point you have a functional plugin, but it does nothing. When launching the server, the plugin is loaded by the core and message '\nBook plugin loaded\n' is displayed in the console.\n\n\nCreate routes\n\n\nTo add features to our Book plugin we need to define routes.\n\n\nCreate a file \nconf.json\n at the root of your plugin directory. Take a look at \nconf.json documentation\n for more details about \nconf.json\n file.\n\n\nFor our example, let's create a public route, a private route and a Web Service route.\n\n\n{\n  \nroutes\n : {\n    \npublic\n : {\n      \nget /:id\n : \ncontrollers/bookController.displayBookAction\n\n    },\n    \nprivate\n : {\n      \nget /read/:id\n : \ncontrollers/bookController.readBookAction\n\n    },\n    \nws\n: {\n      \nget /read/:id\n : \ncontrollers/bookController.readBookAction\n\n    }\n  }\n}\n\n\n\n\nAs a reminder :\n\n\n\n\npublic routes will be mounted on \n/book/\n\n\nprivate routes will be mounted on \n/be/book/\n\n\nWeb Service routes will be mounted on \n/book/\n (but on another server)\n\n\n\n\nCreate the controller\n\n\n3 routes have been defined in \nconf.json\n :\n\n\n\n\n/book/:id\n pointing to \ncontrollers/bookController.js\n, method \ndisplayBookAction\n\n\n/book/read/:id\n pointing to \ncontrollers/bookController.js\n, method \nreadBookAction\n\n\n/book/read/:id\n pointing to \ncontrollers/bookController.js\n, method \nreadBookAction\n\n\n\n\nCreate a file \ncontrollers/bookController.js\n with \ndisplayBookAction\n and \nreadBookAction\n methods :\n\n\n'use strict';\n\n// Module dependencies\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Displays a book.\n */\nmodule.exports.displayBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      title: 'Journey to the center of the earth',\n      summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson (\nHeimskringla\n; the chronicle of the Norwegian kings who ruled over Iceland).'\n    }\n  };\n\n  // Display template book.html using Mustache template\n  response.render('book', books[bookId]);\n};\n\n/**\n * Reads book content and return it as a JSON object.\n */\nmodule.exports.readBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      content: 'Journey to the center of the earth'\n    }\n  };\n\n  response.send({\n    book: books[bookId].content\n  });\n\n};\n\n\n\n\nYou can now restart your server, connect to the back end (/be/login) and navigate to \n/be/book/read/1\n to read the book.\n\n\nCreate a template\n\n\nThe public route \n/book/:id\n call the \ndisplayBookAction\n function on the \nbookController\n.\n\n\ndisplayBookAction\n needs a template \nbook.html\n to display information about the book.\n\n\nCreate a file \nviews/book.html\n :\n\n\n!DOCTYPE html\n\n\nhtml\n\n  \nbody\n\n    \ndiv\n\n      \nh1\n{{title}}\n/h1\n\n      \np\n{{summary}}\n/p\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nAnd add the \nviews\n directory to the list of directories containing Mustache templates (in \nconf.json\n file) :\n\n\n{\n  \nviewsFolders\n : [\n    \nviews\n\n  ]\n}\n\n\n\n\nYou can now restart your server and navigate to \n/book/1\n to have information about the book.\n\n\nAdd directory of resources\n\n\nYou can add an \nassets\n directory at the root of your plugin, all files inside that directory will be served as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on \n/book/\n, thus to access image \nassets/test.jpg\n you have to call \n/book/test.jpg\n.\n\n\nAdd page to the back end\n\n\nPlugins can add pages to the back end menu.\n\n\nConfigure page\n\n\nAs described in \nconf.json documentation\n you can add a page to the back end :\n\n\n{\n  \nbackOffice\n: {\n    \nmenu\n : [\n      {\n        \nlabel\n : \nBooks\n,\n        \nsubMenu\n : [\n          {\n            \nlabel\n : \nConfiguration\n,\n            \npath\n : \nconfig\n\n          }\n        ]\n      }\n    ]\n  }\n}\n\n\n\n\nCreate AngularJS module\n\n\nAs OpenVeo back end is written in AngularJS, we must create an AngularJS module to add pages to the back end.\n\n\nCreate a file \nassets/be/js/BookApp.js\n :\n\n\n(function(angular) {\n\n  'use strict';\n\n  // Module name must respect the form ov.PLUGIN_DIRECTORY_NAME\n  var app = angular.module(\nov.book\n, []);\n\n  /**\n   * Configures the ov.book application by adding new routes.\n   */\n  app.config(['$routeProvider', function($routeProvider) {\n\n    // Add route /book/config\n    $routeProvider.when('/book/config', {\n      templateUrl: '/book/be/views/config.html',\n      controller: 'BookController',\n      title: 'Book configuration'\n    });\n\n  }]);\n\n  /**\n   * Defines the book controller for the configuration page.\n   */\n  function BookController($scope) {\n\n  }\n\n  app.controller('BookController', BookController);\n  BookController.$inject = ['$scope'];\n\n})(angular);\n\n\n\n\nCreate the partial file \nassets/be/views/config.html\n :\n\n\np\nConfiguration template\n/p\n\n\n\n\n\nAnd add \nBookApp.js\n to the list of scripts to load with the back end (\nin conf.json\n) :\n\n\n{\n  \nbackOffice\n: {\n    \nscriptFiles\n : {\n      \ndev\n : [\n        \n/book/be/js/BookApp.js\n\n      ]\n    }\n  }\n}\n\n\n\n\nTranslate your back end pages\n\n\nYou can translate your back end pages using the back end dictionary called \nadmin-back-office\n. Core will search for an \ni18n\n directory to look for dictionaries.\n\n\nCreate an \ni18n\n directory with french and english dictionaries for the back end :\n\n\ni18n/admin-back-office-en.json\n :\n\n\n{\n  \nBOOK\n : {\n    \nCONFIGURATION\n : \nConfiguration template\n\n  }\n}\n\n\n\n\ni18n/admin-back-office-fr.json\n :\n\n\n{\n  \nBOOK\n : {\n    \nCONFIGURATION\n : \nTemplate de configuration\n\n  }\n}\n\n\n\n\nYou can now translate your \nconfig.html\n file :\n\n\np\n{{'BOOK.CONFIGURATION' | translate}}\n/p\n\n\n\n\n\nNb :\n For more information on internationalization please refer to the \ni18n documentation\n.", 
            "title": "Write a plugin"
        }, 
        {
            "location": "/developers/write-plugin/#introduction", 
            "text": "As OpenVeo server starts, all plugins found in  node_modules/@openveo/  will be loaded. Each plugin can add routes and add its own pages in the back end.  Let's pretend we want to create a plugin called  book  to manage a list of books.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-directory", 
            "text": "The first thing we need is a plugin's directory, create a directory  book  under  node_modules/@openveo/  ( node_modules/@openveo/book ).", 
            "title": "Create plugin's directory"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-main-file", 
            "text": "A plugin must have a class which extends  Plugin  class.  Create a file  BookPlugin.js  at the root of your plugin directory.  'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar express = require('express');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookPlugin.\n */\nfunction BookPlugin() {\n\n  // Creates a public router\n  // It will be automatically mounted on /book/ by the core\n  this.router = express.Router();\n\n  // Creates a private router\n  // All routes associated to the private router require a back end authentication\n  // It will be automatically mounted on /be/book/ by the core\n  this.privateRouter = express.Router();\n\n  // Creates a Web Service router\n  // All routes associated to the Web Service router will be part of the Web Service\n  // It will be automatically mounter on /book/ by the core (but on another server)\n  this.webServiceRouter = express.Router();\n\n}\n\n// Expose BookPlugin\nmodule.exports = BookPlugin;\n\n// Extends Plugin\nutil.inherits(BookPlugin, openVeoAPI.Plugin);\n\n/**\n * Optional  start  method automatically called by core application\n * after plugin is loaded.\n */\nBookPlugin.prototype.start = function() {\n  console.log('Book plugin loaded');\n};  If you don't want to expose public routes, private routes or Web Service routes, just remove the corresponding router.", 
            "title": "Create plugin's main file"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-entry-point", 
            "text": "A plugin must have an entry point. Either the one described in your  package.json  file (if you have one) or an  index.js  file. This is the file loaded by the core.  Create a file  index.js  at the root of your plugin directory.  'use strict';\n\n// Module dependencies\nvar path = require('path');\n\n// Set module root directory\nprocess.rootBook = __dirname;\n\n// Define a new method on process object to be able to require\n// a module with a path relative to plugin's root directory\nprocess.requireBook = function(filePath) {\n  return require(path.join(process.requireBook, filePath));\n};\n\n// Expose the BookPlugin\nmodule.exports = process.requireBook('app/server/BookPlugin.js');  As the plugin will be loaded by OpenVeo core, root of the OpenVeo application will be the root of OpenVeo core and not the root of your plugin. To avoid confusion and collision between the core and your plugin, define a property process.root PLUGIN_NAME  to have a reference to the root of your plugin.  A best practice is to also add a require PLUGIN_NAME  function to load your JavaScript files with paths relative to the root of your plugin. \nFor example, if you want to load a file  dir/test.js  from file  dir/subDir/index.js  instead of writing :  var test = require('../test.js');  You can write :  var test = process.requireBook('dir/subDir/test.js');  Like that moving the file  index.js  won't break your code.  At this point you have a functional plugin, but it does nothing. When launching the server, the plugin is loaded by the core and message ' Book plugin loaded ' is displayed in the console.", 
            "title": "Create plugin's entry point"
        }, 
        {
            "location": "/developers/write-plugin/#create-routes", 
            "text": "To add features to our Book plugin we need to define routes.  Create a file  conf.json  at the root of your plugin directory. Take a look at  conf.json documentation  for more details about  conf.json  file.  For our example, let's create a public route, a private route and a Web Service route.  {\n   routes  : {\n     public  : {\n       get /:id  :  controllers/bookController.displayBookAction \n    },\n     private  : {\n       get /read/:id  :  controllers/bookController.readBookAction \n    },\n     ws : {\n       get /read/:id  :  controllers/bookController.readBookAction \n    }\n  }\n}  As a reminder :   public routes will be mounted on  /book/  private routes will be mounted on  /be/book/  Web Service routes will be mounted on  /book/  (but on another server)", 
            "title": "Create routes"
        }, 
        {
            "location": "/developers/write-plugin/#create-the-controller", 
            "text": "3 routes have been defined in  conf.json  :   /book/:id  pointing to  controllers/bookController.js , method  displayBookAction  /book/read/:id  pointing to  controllers/bookController.js , method  readBookAction  /book/read/:id  pointing to  controllers/bookController.js , method  readBookAction   Create a file  controllers/bookController.js  with  displayBookAction  and  readBookAction  methods :  'use strict';\n\n// Module dependencies\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Displays a book.\n */\nmodule.exports.displayBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      title: 'Journey to the center of the earth',\n      summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).'\n    }\n  };\n\n  // Display template book.html using Mustache template\n  response.render('book', books[bookId]);\n};\n\n/**\n * Reads book content and return it as a JSON object.\n */\nmodule.exports.readBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      content: 'Journey to the center of the earth'\n    }\n  };\n\n  response.send({\n    book: books[bookId].content\n  });\n\n};  You can now restart your server, connect to the back end (/be/login) and navigate to  /be/book/read/1  to read the book.", 
            "title": "Create the controller"
        }, 
        {
            "location": "/developers/write-plugin/#create-a-template", 
            "text": "The public route  /book/:id  call the  displayBookAction  function on the  bookController .  displayBookAction  needs a template  book.html  to display information about the book.  Create a file  views/book.html  :  !DOCTYPE html  html \n   body \n     div \n       h1 {{title}} /h1 \n       p {{summary}} /p \n     /div \n   /body  /html   And add the  views  directory to the list of directories containing Mustache templates (in  conf.json  file) :  {\n   viewsFolders  : [\n     views \n  ]\n}  You can now restart your server and navigate to  /book/1  to have information about the book.", 
            "title": "Create a template"
        }, 
        {
            "location": "/developers/write-plugin/#add-directory-of-resources", 
            "text": "You can add an  assets  directory at the root of your plugin, all files inside that directory will be served as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on  /book/ , thus to access image  assets/test.jpg  you have to call  /book/test.jpg .", 
            "title": "Add directory of resources"
        }, 
        {
            "location": "/developers/write-plugin/#add-page-to-the-back-end", 
            "text": "Plugins can add pages to the back end menu.", 
            "title": "Add page to the back end"
        }, 
        {
            "location": "/developers/write-plugin/#configure-page", 
            "text": "As described in  conf.json documentation  you can add a page to the back end :  {\n   backOffice : {\n     menu  : [\n      {\n         label  :  Books ,\n         subMenu  : [\n          {\n             label  :  Configuration ,\n             path  :  config \n          }\n        ]\n      }\n    ]\n  }\n}", 
            "title": "Configure page"
        }, 
        {
            "location": "/developers/write-plugin/#create-angularjs-module", 
            "text": "As OpenVeo back end is written in AngularJS, we must create an AngularJS module to add pages to the back end.  Create a file  assets/be/js/BookApp.js  :  (function(angular) {\n\n  'use strict';\n\n  // Module name must respect the form ov.PLUGIN_DIRECTORY_NAME\n  var app = angular.module( ov.book , []);\n\n  /**\n   * Configures the ov.book application by adding new routes.\n   */\n  app.config(['$routeProvider', function($routeProvider) {\n\n    // Add route /book/config\n    $routeProvider.when('/book/config', {\n      templateUrl: '/book/be/views/config.html',\n      controller: 'BookController',\n      title: 'Book configuration'\n    });\n\n  }]);\n\n  /**\n   * Defines the book controller for the configuration page.\n   */\n  function BookController($scope) {\n\n  }\n\n  app.controller('BookController', BookController);\n  BookController.$inject = ['$scope'];\n\n})(angular);  Create the partial file  assets/be/views/config.html  :  p Configuration template /p   And add  BookApp.js  to the list of scripts to load with the back end ( in conf.json ) :  {\n   backOffice : {\n     scriptFiles  : {\n       dev  : [\n         /book/be/js/BookApp.js \n      ]\n    }\n  }\n}", 
            "title": "Create AngularJS module"
        }, 
        {
            "location": "/developers/write-plugin/#translate-your-back-end-pages", 
            "text": "You can translate your back end pages using the back end dictionary called  admin-back-office . Core will search for an  i18n  directory to look for dictionaries.  Create an  i18n  directory with french and english dictionaries for the back end :  i18n/admin-back-office-en.json  :  {\n   BOOK  : {\n     CONFIGURATION  :  Configuration template \n  }\n}  i18n/admin-back-office-fr.json  :  {\n   BOOK  : {\n     CONFIGURATION  :  Template de configuration \n  }\n}  You can now translate your  config.html  file :  p {{'BOOK.CONFIGURATION' | translate}} /p   Nb :  For more information on internationalization please refer to the  i18n documentation .", 
            "title": "Translate your back end pages"
        }, 
        {
            "location": "/developers/compilation/", 
            "text": "Introduction\n\n\nOpenVeo back end is written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance.\n\n\nCompiling SASS files\n\n\nYou can compile the back end SASS files using the following command :\n\n\ngrunt compass:dist\n\n\n\nOr you can watch SASS files changes using the following command :\n\n\ngrunt\n\n\n\nCompiling JavaScript files\n\n\nYou'll probably want to compile AngularJS files, in production, for better performance. You can do it using :\n\n\ngrunt prod", 
            "title": "CSS / SASS / JS compilation"
        }, 
        {
            "location": "/developers/compilation/#introduction", 
            "text": "OpenVeo back end is written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/compilation/#compiling-sass-files", 
            "text": "You can compile the back end SASS files using the following command :  grunt compass:dist  Or you can watch SASS files changes using the following command :  grunt", 
            "title": "Compiling SASS files"
        }, 
        {
            "location": "/developers/compilation/#compiling-javascript-files", 
            "text": "You'll probably want to compile AngularJS files, in production, for better performance. You can do it using :  grunt prod", 
            "title": "Compiling JavaScript files"
        }, 
        {
            "location": "/developers/template-engine/", 
            "text": "OpenVeo uses \nMustache\n as the template engine. You have to declare your directory containing template files before using a mustache template file. You can do it in \nconf.json\n file.\n\n\nThen you can call the template using \nrender express function\n in your controller action.", 
            "title": "Template engine"
        }, 
        {
            "location": "/developers/logger/", 
            "text": "Introduction\n\n\nAll server logs are performed by module \nWinston\n.\n\n\nUse OpenVeo logger\n\n\nBy default OpenVeo core creates one logger named \nopenveo\n. You can get this logger using the following code :\n\n\nprocess.logger.silly('Silly log');\nprocess.logger.debug('Debug log');\nprocess.logger.verbose('Verbose log');\nprocess.logger.info('Info log');\nprocess.logger.warn('Warn log');\nprocess.logger.error('Error log');", 
            "title": "Logger"
        }, 
        {
            "location": "/developers/logger/#introduction", 
            "text": "All server logs are performed by module  Winston .", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/logger/#use-openveo-logger", 
            "text": "By default OpenVeo core creates one logger named  openveo . You can get this logger using the following code :  process.logger.silly('Silly log');\nprocess.logger.debug('Debug log');\nprocess.logger.verbose('Verbose log');\nprocess.logger.info('Info log');\nprocess.logger.warn('Warn log');\nprocess.logger.error('Error log');", 
            "title": "Use OpenVeo logger"
        }, 
        {
            "location": "/developers/i18n/", 
            "text": "Introduction\n\n\nOpenVeo translations are grouped by dictionaries (JSON files in i18n directory). Actually the server is capable of returning a dictionary by its name and language. Nothing more. The OpenVeo back end is translated on the client side application (AngularJS).\n\n\nDictionaries\n\n\nDictionaries are all stored in \ni18n directory\n. Dictionary file name is composed of the name of the dictionary followed by the language code :\n\n\n[DICTIONARY_NAME]\n-\n[LANGUAGE_CODE]\n.json\n\n\nWith :\n\n\n\n\n[DICTIONARY_NAME]\n the name of the dictionary\n\n\n[LANGUAGE_CODE]\n the language code\n\n\n\n\ne.g.\n \nmy-dictionary\n-\nen_ca\n.json (will contain translations of dictionary \"my-dictionary\" for Canadian english)\n\n\ne.g.\n \nmy-dictionary\n-\nfr\n.json (will contain translations of dictionary \"my-dictionary\" for French)\n\n\nIf the dictionary must be accessible only by users authenticated to the back end, you must add the prefix : \nadmin-\n.\n\n\ne.g.\n \nadmin-\nmy-dictionary-en_ca.json\n\n\nGet a public dictionary\n\n\nFrom client side, you can request a dictionary using \n/getDictionary/:dictionary/:code\n\n\ne.g.\n \n/getDictionary/my-dictionary/en_ca\n\n\nGet a back end dictionary\n\n\nFrom client side, you can request a back end dictionary (requiring an authenticated user) using \n/be/getDictionary/:dictionary/:code\n\n\ne.g.\n \n/be/getDictionary/my-dictionary/en_ca\n\n\nNb :\n Your dictionary file will be \nadmin-my-dictionary-en_ca.json\n\n\nYou can use the back end AngularJS API (module \nov.i18n\n) to help you manipulate dictionaries.\n\n\nOverride a translation\n\n\nIf you create, in your plugin, a dictionary with the same as an already existing dictionary, it will be merged. For example, if OpenVeo core defines a dictionary called \nlogin-en.json\n with the following translations :\n\n\n{\n  \nLOGIN\n : {\n    \nPAGE_TITLE\n : \nOpenveo - Sign In\n,\n    \nLOGIN\n : \nUser\n,\n    \nLOGIN_DESCRIPTION\n : \nEnter user name\n,\n    \nPASSWORD\n : \nPassword\n,\n    \nPASSWORD_DESCRIPTION\n : \nEnter password\n,\n    \nSUBMIT\n : \nSubmit\n,\n    \nERROR\n : \nWrong user and / or password\n\n  }\n}\n\n\n\n\nIf you create a dictionary with the same name in your plugin (\ni18n/login-en.json\n) with the following translations :\n\n\n{\n  \nLOGIN\n : {\n    \nPAGE_TITLE\n : \nMy page title\n,\n    \nANOTHER_TRANSLATION\n : \nMy new translation\n\n  }\n}\n\n\n\n\nCalling \n/getDictionary/login/en\n will return :\n\n\n{\n  \nLOGIN\n : {\n    \nPAGE_TITLE\n : \nMy page title\n,\n    \nLOGIN\n : \nUser\n,\n    \nLOGIN_DESCRIPTION\n : \nEnter user name\n,\n    \nPASSWORD\n : \nPassword\n,\n    \nPASSWORD_DESCRIPTION\n : \nEnter password\n,\n    \nSUBMIT\n : \nSubmit\n,\n    \nERROR\n : \nWrong user and / or password\n,\n    \nANOTHER_TRANSLATION\n : \nMy new translation\n\n  }\n}", 
            "title": "I18N and I10N"
        }, 
        {
            "location": "/developers/i18n/#introduction", 
            "text": "OpenVeo translations are grouped by dictionaries (JSON files in i18n directory). Actually the server is capable of returning a dictionary by its name and language. Nothing more. The OpenVeo back end is translated on the client side application (AngularJS).", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/i18n/#dictionaries", 
            "text": "Dictionaries are all stored in  i18n directory . Dictionary file name is composed of the name of the dictionary followed by the language code :  [DICTIONARY_NAME] - [LANGUAGE_CODE] .json  With :   [DICTIONARY_NAME]  the name of the dictionary  [LANGUAGE_CODE]  the language code   e.g.   my-dictionary - en_ca .json (will contain translations of dictionary \"my-dictionary\" for Canadian english)  e.g.   my-dictionary - fr .json (will contain translations of dictionary \"my-dictionary\" for French)  If the dictionary must be accessible only by users authenticated to the back end, you must add the prefix :  admin- .  e.g.   admin- my-dictionary-en_ca.json", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/developers/i18n/#get-a-public-dictionary", 
            "text": "From client side, you can request a dictionary using  /getDictionary/:dictionary/:code  e.g.   /getDictionary/my-dictionary/en_ca", 
            "title": "Get a public dictionary"
        }, 
        {
            "location": "/developers/i18n/#get-a-back-end-dictionary", 
            "text": "From client side, you can request a back end dictionary (requiring an authenticated user) using  /be/getDictionary/:dictionary/:code  e.g.   /be/getDictionary/my-dictionary/en_ca  Nb :  Your dictionary file will be  admin-my-dictionary-en_ca.json  You can use the back end AngularJS API (module  ov.i18n ) to help you manipulate dictionaries.", 
            "title": "Get a back end dictionary"
        }, 
        {
            "location": "/developers/i18n/#override-a-translation", 
            "text": "If you create, in your plugin, a dictionary with the same as an already existing dictionary, it will be merged. For example, if OpenVeo core defines a dictionary called  login-en.json  with the following translations :  {\n   LOGIN  : {\n     PAGE_TITLE  :  Openveo - Sign In ,\n     LOGIN  :  User ,\n     LOGIN_DESCRIPTION  :  Enter user name ,\n     PASSWORD  :  Password ,\n     PASSWORD_DESCRIPTION  :  Enter password ,\n     SUBMIT  :  Submit ,\n     ERROR  :  Wrong user and / or password \n  }\n}  If you create a dictionary with the same name in your plugin ( i18n/login-en.json ) with the following translations :  {\n   LOGIN  : {\n     PAGE_TITLE  :  My page title ,\n     ANOTHER_TRANSLATION  :  My new translation \n  }\n}  Calling  /getDictionary/login/en  will return :  {\n   LOGIN  : {\n     PAGE_TITLE  :  My page title ,\n     LOGIN  :  User ,\n     LOGIN_DESCRIPTION  :  Enter user name ,\n     PASSWORD  :  Password ,\n     PASSWORD_DESCRIPTION  :  Enter password ,\n     SUBMIT  :  Submit ,\n     ERROR  :  Wrong user and / or password ,\n     ANOTHER_TRANSLATION  :  My new translation \n  }\n}", 
            "title": "Override a translation"
        }, 
        {
            "location": "/developers/coding-standards/", 
            "text": "OpenVeo uses Node.js coding standards. \nESLint\n is used to validate coding rules. You can launch a code verification using the following command :\n\n\ngrunt eslint\n\n\n\nNb :\n Both Node.js and AngularJS parts of OpenVeo must respect the same coding standards", 
            "title": "Coding standards"
        }, 
        {
            "location": "/developers/unit-tests/", 
            "text": "Node.js unit tests\n\n\nServer side unit tests are performed using \nMocha\n and \nChai\n. You can launch server unit tests with the following command :\n\n\ngrunt mochaTest\n\n\n\nAngularJS unit tests\n\n\nClient side unit tests are performed using \nKarma\n. You can launch client unit tests with the following command :\n\n\ngrunt karma", 
            "title": "Unit tests"
        }, 
        {
            "location": "/developers/unit-tests/#nodejs-unit-tests", 
            "text": "Server side unit tests are performed using  Mocha  and  Chai . You can launch server unit tests with the following command :  grunt mochaTest", 
            "title": "Node.js unit tests"
        }, 
        {
            "location": "/developers/unit-tests/#angularjs-unit-tests", 
            "text": "Client side unit tests are performed using  Karma . You can launch client unit tests with the following command :  grunt karma", 
            "title": "AngularJS unit tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/", 
            "text": "Introduction\n\n\nEnd to end tests are performed using \nProtractor\n.\n\n\nEach plugin (and OpenVeo core) defines a list of test suites in \ntests/client/protractorSuites.json\n.\n\n\nInstall Protractor globally\n\n\nFirst of all you need to install Protractor, all information are available on Protractor's web site.\n\n\nRemove grunt-protractor-runner local protractor\n\n\nrm -rf node_modules/grunt-protractor-runner/node_modules/protractor\n\n\n\nConfigure tests\n\n\nTo be able to launch end to end tests, OpenVeo needs to find the selenium jar and the chrome driver file installed with Protractor.\nYou can specify the path of the selenium jar using \nSELENIUM_JAR\n environment variable and chrome driver using \nCHROME_DRIVER\n environment variable.\n\n\nYou also need to specify a new database which will be used during tests. To do so, you can add a new configuration file in user's directory under \n~/.openveo/core\n called \ndatabaseTestConf.json\n.\n\n\n~/.openveo/core/databaseTestConf.json\n\n\n{\n  \ntype\n: \nmongodb\n,\n  \nhost\n: \nlocalhost\n,\n  \nport\n: 27017,\n  \ndatabase\n: \nopenveo-test\n,\n  \nusername\n: \nopenveo\n,\n  \npassword\n: \nopenveo\n\n}\n\n\n\n\nWARNING\n : Each time you launch end to end tests, all information will be removed from this database ! DO NOT use the same database as the one described in \ndatabaseConf.json\n\n\nWriting tests\n\n\nBoot steps\n\n\nWhen launching end to end tests, several things happen before the first test is launched :\n\n\n\n\nDatabase defined in \n~/.openveo/core/databaseTestConf.json\n is dropped\n\n\nUsers, roles and applications described in \ntests/client/e2eTests/database/data.json\n, from core and plugins, are inserted into database\n\n\nTests suites files, in \ntests/client/e2eTests/protractorSuites.json\n from core and plugins, are merged into one single file (\ntests/client/e2eTests/suites/suites.json\n)\n\n\nA database connection is made to be able to use models in tests\n\n\nAll plugins are loaded and available in ApplicationStorage\n\n\n\n\nAdd users, roles and application before tests\n\n\nUsers, roles and applications can be added before tests are launched using \ntests/client/e2eTests/database/data.json\n configuration file.\n\n\nStructure is as follow :\n\n\n{\n  \nroles\n: {\n    ...\n  },\n  \nusers\n: {\n    ...\n  },\n  \napplications\n: {\n    ...\n  }\n}\n\n\n\n\nCreate a role\n\n\n{\n  \nroles\n: {\n    \ncoreAdmin\n: { // Id of the role to use when creating users\n      \nname\n: \ncore-admin\n, // The name of the role\n      \npermissions\n: [ // The list of permissions ids as described in conf.json file\n        \ncreate-application\n,\n        \nupdate-application\n,\n        \ndelete-application\n,\n        \ncreate-taxonomy\n,\n        \nupdate-taxonomy\n,\n        \ndelete-taxonomy\n,\n        \ncreate-user\n,\n        \nupdate-user\n,\n        \ndelete-user\n,\n        \ncreate-role\n,\n        \nupdate-role\n,\n        \ndelete-role\n,\n        \naccess-applications-page\n,\n        \naccess-users-page\n,\n        \naccess-roles-page\n\n      ]\n    }\n  }\n}\n\n\n\n\nCreate a user\n\n\n{\n  \nusers\n: {\n    \ncoreAdmin\n: { // Id of the user (not used)\n      \nname\n: \ncore-admin\n, // The name of the user\n      \nemail\n: \ncore-admin@veo-labs.com\n, User's email\n      \npassword\n: \ncore-admin\n, // User's password\n      \nroles\n: [ \ncoreAdmin\n ] // User's list of roles (role ids are the one described in the same file)\n    }\n  }\n}\n\n\n\n\nCreate an application\n\n\n{\n  \napplications\n: {\n    \ncoreApplicationsGuest\n: { // Id of the application (not used)\n      \nname\n: \ncore-applications-guest\n, // Name of the application\n      \nscopes\n: [ \nvideo\n ] // List of scope ids for the application\n    }\n  }\n}\n\n\n\n\nCreate test\n\n\nCreate your test file in \ntests/client/e2eTests/\n then update the list of suites, if necessary, in  \ntests/client/e2eTests/suites/suites.json\n.\n\n\nDebug\n\n\nIf a test fails, a screenshot of the browser at the instant is taken and available in \nbuild/screenshots\n of the core.\n\n\nLaunch server in test mode\n\n\nnode server.js -t\n\n\n\nLaunch end to end tests\n\n\n# Launch all end to end tests on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true\n\n# Launch all end to end tests on firefox\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"firefox\\\"}\" --directConnect=true\n\n# Launch only homePage suite on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true --suite=\"homePage\"", 
            "title": "End to end tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#introduction", 
            "text": "End to end tests are performed using  Protractor .  Each plugin (and OpenVeo core) defines a list of test suites in  tests/client/protractorSuites.json .", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/end-to-end-tests/#install-protractor-globally", 
            "text": "First of all you need to install Protractor, all information are available on Protractor's web site.", 
            "title": "Install Protractor globally"
        }, 
        {
            "location": "/developers/end-to-end-tests/#remove-grunt-protractor-runner-local-protractor", 
            "text": "rm -rf node_modules/grunt-protractor-runner/node_modules/protractor", 
            "title": "Remove grunt-protractor-runner local protractor"
        }, 
        {
            "location": "/developers/end-to-end-tests/#configure-tests", 
            "text": "To be able to launch end to end tests, OpenVeo needs to find the selenium jar and the chrome driver file installed with Protractor.\nYou can specify the path of the selenium jar using  SELENIUM_JAR  environment variable and chrome driver using  CHROME_DRIVER  environment variable.  You also need to specify a new database which will be used during tests. To do so, you can add a new configuration file in user's directory under  ~/.openveo/core  called  databaseTestConf.json .  ~/.openveo/core/databaseTestConf.json  {\n   type :  mongodb ,\n   host :  localhost ,\n   port : 27017,\n   database :  openveo-test ,\n   username :  openveo ,\n   password :  openveo \n}  WARNING  : Each time you launch end to end tests, all information will be removed from this database ! DO NOT use the same database as the one described in  databaseConf.json", 
            "title": "Configure tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#writing-tests", 
            "text": "", 
            "title": "Writing tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#boot-steps", 
            "text": "When launching end to end tests, several things happen before the first test is launched :   Database defined in  ~/.openveo/core/databaseTestConf.json  is dropped  Users, roles and applications described in  tests/client/e2eTests/database/data.json , from core and plugins, are inserted into database  Tests suites files, in  tests/client/e2eTests/protractorSuites.json  from core and plugins, are merged into one single file ( tests/client/e2eTests/suites/suites.json )  A database connection is made to be able to use models in tests  All plugins are loaded and available in ApplicationStorage", 
            "title": "Boot steps"
        }, 
        {
            "location": "/developers/end-to-end-tests/#add-users-roles-and-application-before-tests", 
            "text": "Users, roles and applications can be added before tests are launched using  tests/client/e2eTests/database/data.json  configuration file.  Structure is as follow :  {\n   roles : {\n    ...\n  },\n   users : {\n    ...\n  },\n   applications : {\n    ...\n  }\n}  Create a role  {\n   roles : {\n     coreAdmin : { // Id of the role to use when creating users\n       name :  core-admin , // The name of the role\n       permissions : [ // The list of permissions ids as described in conf.json file\n         create-application ,\n         update-application ,\n         delete-application ,\n         create-taxonomy ,\n         update-taxonomy ,\n         delete-taxonomy ,\n         create-user ,\n         update-user ,\n         delete-user ,\n         create-role ,\n         update-role ,\n         delete-role ,\n         access-applications-page ,\n         access-users-page ,\n         access-roles-page \n      ]\n    }\n  }\n}  Create a user  {\n   users : {\n     coreAdmin : { // Id of the user (not used)\n       name :  core-admin , // The name of the user\n       email :  core-admin@veo-labs.com , User's email\n       password :  core-admin , // User's password\n       roles : [  coreAdmin  ] // User's list of roles (role ids are the one described in the same file)\n    }\n  }\n}  Create an application  {\n   applications : {\n     coreApplicationsGuest : { // Id of the application (not used)\n       name :  core-applications-guest , // Name of the application\n       scopes : [  video  ] // List of scope ids for the application\n    }\n  }\n}  Create test  Create your test file in  tests/client/e2eTests/  then update the list of suites, if necessary, in   tests/client/e2eTests/suites/suites.json .", 
            "title": "Add users, roles and application before tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#debug", 
            "text": "If a test fails, a screenshot of the browser at the instant is taken and available in  build/screenshots  of the core.", 
            "title": "Debug"
        }, 
        {
            "location": "/developers/end-to-end-tests/#launch-server-in-test-mode", 
            "text": "node server.js -t", 
            "title": "Launch server in test mode"
        }, 
        {
            "location": "/developers/end-to-end-tests/#launch-end-to-end-tests", 
            "text": "# Launch all end to end tests on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true\n\n# Launch all end to end tests on firefox\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"firefox\\\"}\" --directConnect=true\n\n# Launch only homePage suite on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true --suite=\"homePage\"", 
            "title": "Launch end to end tests"
        }, 
        {
            "location": "/api/", 
            "text": "Backend AngularJS API\n\n\nThe \nBackend API\n helps you write backend pages for OpenVeo.", 
            "title": "API"
        }, 
        {
            "location": "/api/#backend-angularjs-api", 
            "text": "The  Backend API  helps you write backend pages for OpenVeo.", 
            "title": "Backend AngularJS API"
        }
    ]
}